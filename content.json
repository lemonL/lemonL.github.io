{"meta":{"title":"kitty Blog","subtitle":"农夫山泉有点甜","description":"","author":"kitty","url":"www.kitty.kim","root":"/"},"pages":[{"title":"友情链接","date":"2019-04-03T05:40:08.707Z","updated":"2019-04-03T05:40:08.707Z","comments":false,"path":"links/index.html","permalink":"www.kitty.kim/links/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-03T05:38:49.308Z","updated":"2019-04-03T05:38:49.308Z","comments":true,"path":"links/links.json","permalink":"www.kitty.kim/links/links.json","excerpt":"","text":"{\"Name\":{\"link\":\"http://example.com\",\"avatar\":\"http://example.com/avatar.png\",\"desc\":\"这是一个描述\"}}"},{"title":"About","date":"2016-04-20T20:48:33.000Z","updated":"2019-03-20T08:13:17.675Z","comments":true,"path":"about/index.html","permalink":"www.kitty.kim/about/index.html","excerpt":"","text":"简介1234昵称：kitty 职业：Android开发工程师 经验：物联网(无人机、NB-IOT、智能硬件)、前端(JS、CSS、HTML)、C++(略懂一些) 内容：都是一些琐碎的文章，对感兴趣的新技术会写些文章用来记录.博客经历最早是在CSDN写文章，后来发现体验糟糕的狠，决定自己搭建博客，之前是在阿里云搭建，图片存在七牛云(由于用的是测试域名和空间，被七牛云清空了，导致部分文章没有配图)，服务器到期后换用Coding，Coding三天两头抽风，外加频繁更新导致Pages不稳定，为了不再折腾，转移到了GitHub,文章现在托管在阿里语雀平台上。"},{"title":"Tags","date":"2019-03-28T05:56:45.543Z","updated":"2019-03-28T05:56:45.543Z","comments":true,"path":"tags/index.html","permalink":"www.kitty.kim/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WEB前端 浮动","slug":"yuque/fudong","date":"2019-04-02T07:25:46.000Z","updated":"2019-04-03T03:18:11.654Z","comments":true,"path":"2019/04/02/yuque/fudong/","link":"","permalink":"www.kitty.kim/2019/04/02/yuque/fudong/","excerpt":"","text":"简介浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止，脱离文档流CSS浮动第一个是正常在文档流里，第二个是使用浮动后，就脱离里文档流，可以向右浮动，原先的位置会释放掉，不会继续占用空间如果三个块级元素，只有中间一个块级元素使用浮动，下面的块级元素会继续顶上去，浮动的元素会向上走。如果三个块级元素都使用浮动的化，会并排排列如下图所示：如果内容区域太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”：CSS浮动的使用一般CSS浮动会配合着div使用，父元素div块级元素内，任意浮动，可以做到完好的控制，不会影响其他元素的排列组合","categories":[],"tags":[]},{"title":"WEB前端 定位","slug":"yuque/dingwei","date":"2019-04-02T02:48:07.000Z","updated":"2019-04-03T03:18:11.617Z","comments":true,"path":"2019/04/02/yuque/dingwei/","link":"","permalink":"www.kitty.kim/2019/04/02/yuque/dingwei/","excerpt":"","text":"tags: [Web]categories: Web简介可以使元素定位到相对于父元素或另一个元素甚至浏览器窗口本身的位置。div、h1 或 p 元素常常被称为块级元素。这意味着这些元素会单独占用一行。而span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”。1234&lt;div&gt;文本&lt;p&gt;P元素&lt;/p&gt;&lt;/div&gt;定位分类1.普通流html默认的文档流，从上到下排列，一个块级元素占用一行，框之间的垂直距离是由框的垂直外边距计算出来，以此类推2.相对定位相对定位类似与Android中的relative布局方式，相对于元素在文档中的初始位置。例如：原本是横向摆放3个元素，由于2元素使用了，相对定位后，脱离了文档流控制12345#box_relative &#123; position: relative; left: 30px; top: 20px;&#125;执行后效果：在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间，因此，移动元素会导致它覆盖其它框。3.绝对定位设置为绝对定位的元素框从文档流完全删除，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框，绝对定位是“相对于”父元素来定位的。例如：12345#box_relative &#123; position: absolute; left: 30px; top: 20px;&#125;执行后的效果：","categories":[],"tags":[]},{"title":"Node----fs文件操作","slug":"yuque/cxcglv","date":"2019-03-29T14:41:41.000Z","updated":"2019-04-03T03:18:11.619Z","comments":true,"path":"2019/03/29/yuque/cxcglv/","link":"","permalink":"www.kitty.kim/2019/03/29/yuque/cxcglv/","excerpt":"","text":"Node 的三个组成部分: ECMAScript核心 +全局成员+核心APi成员访问核心成员 ：require(‘核心成员的名称’)用法1const fs=require('fs');fs读取文本1234fs.readFile('../MyApplication/build.gradle', (err, data) =&gt; &#123; if (err) return console.log('读取失败:'+err); console.log('读取成功:'+data); &#125;);fs写入文本1234fs.writeFile('test.txt','啦啦啦啦',(err,data)=&gt;&#123; if(err)return console.log('写入失败：'+err) console.log('写入成功'); &#125;)fs追加文本1234fs.appendFile('test.txt', '追加的数据', (err) =&gt; &#123; if (err) throw 'err'; console.log('数据已追加到文件'); &#125;);fs.stat相关使用12345fs.stat(__dirname,(err,data)=&gt;&#123; //__dirname 当前文件目录 if(err)return console.log('err'+err); console.log('data'+data.size);//获取当前文件大小 单位btye console.log('data'+data.birthtime);//获取当前文件创建时间&#125;)","categories":[],"tags":[]},{"title":"JS高阶函数","slug":"yuque/ciokfo","date":"2019-03-23T16:50:50.000Z","updated":"2019-04-03T03:18:11.619Z","comments":true,"path":"2019/03/24/yuque/ciokfo/","link":"","permalink":"www.kitty.kim/2019/03/24/yuque/ciokfo/","excerpt":"","text":"通俗的理解，函数的嵌套，方法参数定义的类型为function，在函数内部去调用此参数123456789function eat(fn) &#123; setTimeout(function () &#123; console.log('这是测试'); fn(); &#125;, 2000);&#125;eat(function () &#123; console.log('测试结束');&#125;);通过传递一个参数，在2秒过后，会先打印 console.log(‘这是测试’);并调用fn函数中的console.log(‘测试结束’);","categories":[],"tags":[]},{"title":"JS闭包(Closure)","slug":"yuque/qtg5h8","date":"2019-03-23T16:35:43.000Z","updated":"2019-04-03T03:18:11.620Z","comments":true,"path":"2019/03/24/yuque/qtg5h8/","link":"","permalink":"www.kitty.kim/2019/03/24/yuque/qtg5h8/","excerpt":"","text":"闭包(Closure)：在一个函数中，可以访问到另一个函数中的局部变量，就是闭包现象例子：12345678function fn() &#123; var a = 10; return function () &#123; return a; &#125;&#125;var test = fn();console.log(test());以上代码，test()会输出fn()函数当中的a局部变量，此时就是闭包现象。12345678910var heros = document.getElementById('heros');var list = heros.children;for (let index = 0; index &lt; list.length; index++) &#123; var li = list[index]; (function () &#123; li.onclick = function () &#123; console.log(i); //此处闭包了 &#125; &#125;)(i)&#125;查看闭包现象：可以通过浏览器控制台，打断点并进行跟踪，可以看到Scope区域内，有Closure产生，此时就是闭包闭包注意⚠️：闭包虽然是延展了作用域了，但是容易影响性能，因为闭包是延展作用域，本来作用域使用完后会立即释放掉，但因为延展的关系，并没有释放掉。","categories":[],"tags":[]},{"title":"Android DJI Mobile-SDK 开发","slug":"yuque/plnquw","date":"2019-03-20T06:59:15.000Z","updated":"2019-04-03T03:18:11.623Z","comments":true,"path":"2019/03/20/yuque/plnquw/","link":"","permalink":"www.kitty.kim/2019/03/20/yuque/plnquw/","excerpt":"","text":"由于大疆的文档是英文的，看着不太舒服，虽然靠翻译插件进行翻译可也能看，但是来回的切换看比较麻烦，就搞一个中文的教程，基于SDK Version: 3.5.1（书到用时方恨少，后悔当年没好好学习英语）开发准备先去开发者中心注册账号登录个人中心创建应用开发可以参考大疆的Android文档 —— [ DJI ]下载Demo，将Demo 中的lib项目导入自己的项目工程中配置AndroidManifest.xml添加SDK所需要的权限123456789101112131415161718192021&lt;!-- SDK 需要的权限 --&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt; &lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; &lt;uses-permission android:name=\"android.permission.VIBRATE\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;uses-feature android:name=\"android.hardware.camera\" /&gt; &lt;uses-feature android:name=\"android.hardware.camera.autofocus\" /&gt; &lt;uses-feature android:name=\"android.hardware.usb.host\" android:required=\"false\" /&gt; &lt;uses-feature android:name=\"android.hardware.usb.accessory\" android:required=\"true\" /&gt;配置key以及服务12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;meta-data android:name=\"com.dji.sdk.API_KEY\" android:value=\"自己应用申请的key\" /&gt; &lt;!-- 以下是官方dmeo默认的配置 --&gt; &lt;service android:name=\"dji.sdk.sdkmanager.DJIGlobalService\" /&gt; &lt;service android:name=\"dji.internal.geofeature.flyforbid.FlyforbidUpdateService\" /&gt; &lt;!-- Required for receiving GEO system pushing. --&gt; &lt;service android:name=\"dji.sdk.sdkmanager.GeoSyncFileService\"/&gt; &lt;activity android:name=\"dji.sdk.sdkmanager.DJIAoaControllerActivity\" android:theme=\"@android:style/Theme.Translucent\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\" android:resource=\"@xml/accessory_filter\" /&gt; &lt;/activity&gt; &lt;!-- 以上是官方dmeo默认的配置 --&gt; &lt;activity android:name=\".MainActivity\" android:screenOrientation=\"portrait\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;MyApplication用来初始化DJI SDK的一个类，写好后，别忘了配置到AndroidManifest.xml中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import android.app.Application;import android.content.Intent;import android.os.Handler;import android.os.Looper;import android.support.multidex.MultiDex;import android.util.Log;import android.widget.Toast;import dji.common.error.DJIError;import dji.common.error.DJISDKError;import dji.sdk.base.DJIBaseComponent;import dji.sdk.base.DJIBaseProduct;import dji.sdk.products.DJIAircraft;import dji.sdk.sdkmanager.DJISDKManager;/** * Created by kitty * Application 类用来初始化SDK */public class MyApplication extends Application &#123; private static DJIBaseProduct mProduct; private Handler mHandler; public static final String FLAG_CONNECTION_CHANGE =\"com_example_dji_sdkdemo3_connection_change\"; @Override public void onCreate() &#123; super.onCreate(); //初始化SDK DJISDKManager.getInstance().initSDKManager(this, mDJISDKManagerCallback); &#125; /** * 注册监听 */ private DJISDKManager.DJISDKManagerCallback mDJISDKManagerCallback = new DJISDKManager.DJISDKManagerCallback() &#123; //判断是否注册成功回调 @Override public void onGetRegisteredResult(DJIError error) &#123; if (error == DJISDKError.REGISTRATION_SUCCESS) &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(getApplicationContext(), \"注册成功\", Toast.LENGTH_LONG).show(); &#125; &#125;); DJISDKManager.getInstance().startConnectionToProduct(); &#125; else &#123; Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(getApplicationContext(), \"注册失败，或者网络问题\", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; Log.e(\"TAG\", error.toString()); &#125; //监听状态 @Override public void onProductChanged(DJIBaseProduct oldProduct, DJIBaseProduct newProduct) &#123; mProduct = newProduct; if (mProduct != null) &#123; mProduct.setDJIBaseProductListener(mDJIBaseProductListener); &#125; notifyStatusChange(); &#125; &#125;; private DJIBaseProduct.DJIBaseProductListener mDJIBaseProductListener = new DJIBaseProduct.DJIBaseProductListener() &#123; @Override public void onComponentChange(DJIBaseProduct.DJIComponentKey key, DJIBaseComponent oldComponent, DJIBaseComponent newComponent) &#123; if (newComponent != null) &#123; newComponent.setDJIComponentListener(mDJIComponentListener); &#125; notifyStatusChange(); &#125; @Override public void onProductConnectivityChanged(boolean isConnected) &#123; notifyStatusChange(); &#125; &#125;; private DJIBaseComponent.DJIComponentListener mDJIComponentListener = new DJIBaseComponent.DJIComponentListener() &#123; @Override public void onComponentConnectivityChanged(boolean isConnected) &#123; Log.d(\"Alex\", \"onComponentConnectivityChanged: \" + isConnected); notifyStatusChange(); &#125; &#125;; private void notifyStatusChange() &#123; mHandler.removeCallbacks(updateRunnable); mHandler.postDelayed(updateRunnable, 500); &#125; private Runnable updateRunnable = new Runnable() &#123; @Override public void run() &#123; Intent intent = new Intent(FLAG_CONNECTION_CHANGE); sendBroadcast(intent); &#125; &#125;; /** * 获得指定的实例 */ public static synchronized DJIBaseProduct getProductInstance() &#123; if (null == mProduct) &#123; mProduct = DJISDKManager.getInstance().getDJIProduct(); &#125; return mProduct; &#125;&#125;MainActivity界面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/text_connection_status\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"Status: No Product Connected\" android:textColor=\"@android:color/black\" android:textSize=\"20dp\" android:textStyle=\"bold\" android:layout_alignBottom=\"@+id/text_product_info\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"89dp\" /&gt; &lt;TextView android:id=\"@+id/text_product_info\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"150dp\" android:text=\"product_information\" android:textColor=\"@android:color/black\" android:textSize=\"20dp\" android:gravity=\"center\" android:textStyle=\"bold\" /&gt; &lt;Button android:id=\"@+id/btn_open\" android:layout_width=\"150dp\" android:layout_height=\"55dp\" android:layout_centerHorizontal=\"true\" android:layout_marginTop=\"250dp\" android:background=\"@drawable/round_btn\" android:text=\"Open\" android:textColor=\"@android:color/white\" android:textSize=\"20dp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textAppearance=\"?android:attr/textAppearanceSmall\" android:text=\"Demo\" android:id=\"@+id/textView\" android:layout_marginTop=\"30dp\" android:textStyle=\"bold\" android:textSize=\"20dp\" android:textColor=\"@color/colorAccent\" android:layout_alignParentTop=\"true\" android:layout_centerHorizontal=\"true\" /&gt; &lt;/RelativeLayout&gt;Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import android.Manifest;import android.app.Activity;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.Build;import android.os.Bundle;import android.support.v4.app.ActivityCompat;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.TextView;import dji.sdk.base.DJIBaseProduct;import dji.sdk.products.DJIAircraft;/** * Created by kitty on 2017/3/1. * 连接页面 */public class MainActivityextends Activity implements View.OnClickListener, DJIBaseProduct.DJIVersionCallback &#123; private static final String TAG = MainActivity.class.getName(); private TextView mTextConnectionStatus; private TextView mTextProduct; private Button mBtnOpen; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //判断版本，进行动态获取权限 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.VIBRATE, Manifest.permission.INTERNET, Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.WAKE_LOCK, Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_NETWORK_STATE, Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.CHANGE_WIFI_STATE, Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.SYSTEM_ALERT_WINDOW, Manifest.permission.READ_PHONE_STATE, &#125; , 1); &#125; setContentView(R.layout.activity_main); initUI(); //注册广播，连接成功 更新UI用 IntentFilter filter = new IntentFilter(); filter.addAction(MainActivity.FLAG_CONNECTION_CHANGE); registerReceiver(mReceiver, filter); &#125; private void initUI() &#123; mTextConnectionStatus = (TextView) findViewById(R.id.text_connection_status); mTextProduct = (TextView) findViewById(R.id.text_product_info); //open按钮 mBtnOpen = (Button) findViewById(R.id.btn_open); mBtnOpen.setOnClickListener(this); mBtnOpen.setEnabled(false); &#125; //连接成功广播更新UI protected BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; refreshSDKRelativeUI(); &#125; &#125;; //更新UI private void refreshSDKRelativeUI() &#123; DJIBaseProduct mProduct = MainActivity.getProductInstance(); if (null != mProduct &amp;&amp; mProduct.isConnected()) &#123; mBtnOpen.setEnabled(true); String str = mProduct instanceof DJIAircraft ? \"DJIAircraft\" : \"DJIHandHeld\"; mTextConnectionStatus.setText(\"Status: \" + str + \" connected\"); mProduct.setDJIVersionCallback(this); if (null != mProduct.getModel()) &#123; mTextProduct.setText(\"\" + mProduct.getModel().getDisplayName()); &#125; else &#123; mTextProduct.setText(R.string.product_information); &#125; &#125; else &#123; mBtnOpen.setEnabled(false); mTextProduct.setText(R.string.product_information); mTextConnectionStatus.setText(R.string.connection_loose); &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_open: Intent intent = new Intent(this, OpenActivity.class); startActivity(intent); break; default: break; &#125; &#125; @Override public void onProductVersionChange(String s, String s1) &#123; Log.e(\"ceshi\", \"ConnectionActivity.java--&gt;onProductVersionChange()\"); &#125; @Override public void onResume() &#123; Log.e(TAG, \"onResume\"); super.onResume(); &#125; @Override public void onPause() &#123; Log.e(TAG, \"onPause\"); super.onPause(); &#125; @Override public void onStop() &#123; Log.e(TAG, \"onStop\"); super.onStop(); &#125; public void onReturn(View view) &#123; Log.e(TAG, \"onReturn\"); this.finish(); &#125; @Override protected void onDestroy() &#123; Log.e(TAG, \"onDestroy\"); unregisterReceiver(mReceiver); super.onDestroy(); &#125;&#125;OpenActivity界面123456789101112131415&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextureView android:id=\"@+id/video_previewer_surface\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:layout_centerHorizontal=\"true\" /&gt; &lt;/RelativeLayout&gt;Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 连接成功显示页面 */public class OpenActivity extends AppCompatActivity implements TextureView.SurfaceTextureListener &#123; protected TextureView mVideoSurface = null; private static final String TAG = OpenActivity.class.getName(); protected DJICamera.CameraReceivedVideoDataCallback mReceivedVideoDataCallBack = null; DJICodecManager mCodecManager; private DJICamera camera; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout. open); //初始化界面 initUI(); //显示回调 mReceivedVideoDataCallBack = new DJICamera.CameraReceivedVideoDataCallback() &#123; @Override public void onResult(byte[] videoBuffer, int size) &#123; if (mCodecManager != null) &#123; // Send the raw H264 video data to codec manager for decoding mCodecManager.sendDataToDecoder(videoBuffer, size); &#125; else &#123; Log.e(TAG, \"mCodecManager is null\"); &#125; &#125; &#125;; &#125; protected void onProductChange() &#123; initPreviewer(); &#125; @Override public void onResume() &#123; super.onResume(); initPreviewer(); onProductChange(); if (mVideoSurface == null) &#123; Log.e(\"ceshi\", \"mVideoSurface 显示界面为空\"); &#125; &#125; private void initPreviewer() &#123; DJIBaseProduct product = MyApplication.getProductInstance(); if (product == null || !product.isConnected()) &#123;// showToast(getString(R.string.disconnected)); Toast.makeText(getApplicationContext(), \"无连接\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(getApplicationContext(), \"以连接\", Toast.LENGTH_LONG).show(); if (null != mVideoSurface) &#123; mVideoSurface.setSurfaceTextureListener(this); &#125; if (!product.getModel().equals(product.getModel().UnknownAircraft)) &#123; DJICamera camera = product.getCamera(); if (camera != null) &#123; // Set the callback camera.setDJICameraReceivedVideoDataCallback(mReceivedVideoDataCallBack); &#125; &#125; &#125; &#125; private void uninitPreviewer() &#123; DJICamera camera = MyApplication.getProductInstance().getCamera(); if (camera != null) &#123; // Reset the callback MyApplication.getProductInstance().getCamera().setDJICameraReceivedVideoDataCallback(null); &#125; &#125; @Override public void onPause() &#123; super.onPause(); &#125; @Override public void onStop() &#123; uninitPreviewer(); super.onStop(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); uninitPreviewer(); &#125; @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; Log.e(TAG, \"onSurfaceTextureAvailable\"); if (mCodecManager == null) &#123; mCodecManager = new DJICodecManager(this, surface, width, height); &#125; &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123; Log.e(TAG, \"onSurfaceTextureSizeChanged\"); &#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; Log.e(TAG, \"onSurfaceTextureDestroyed\"); if (mCodecManager != null) &#123; mCodecManager.cleanSurface(); mCodecManager = null; &#125; return false; &#125; @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123; &#125; private void initUI() &#123; // 准备界面 mVideoSurface = (TextureView) findViewById(R.id.video_previewer_surface); if (null != mVideoSurface) &#123; mVideoSurface.setSurfaceTextureListener(this); &#125; &#125;&#125;测试步骤手机连接遥控器选择dmeo打开连接飞机成功，点击open按钮，成功的话会显示画面","categories":[],"tags":[]},{"title":"C++ 虚析构和虚函数的原理","slug":"yuque/cvfg0g","date":"2019-03-18T09:55:51.000Z","updated":"2019-04-03T03:18:11.624Z","comments":true,"path":"2019/03/18/yuque/cvfg0g/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/cvfg0g/","excerpt":"","text":"C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议同名函数下，有virtual修饰=覆盖，无virtual=隐藏1231、类内没有数据成员的情况下，实例化对象所占字节为1字节，有数据成员为数据成员的大小之和；2、类内有虚成员函数，那么在实例化的时候会产生一个虚函数表指针，对象的大小为4字节。3、虚析构函数可以使类实例对象的时候一样为产生一个虚函数表指针，大小为4字节；如果父类成员函数被virtual修饰，子类继承，会继承父类的虚函数表，如果子类同名的函数也被virtual修饰。也可以把父类的虚函数表的同名函数指针地址覆盖掉，变为自己的指针地址。例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;/** * C++虚构函数和虚函数指针的原理 */using namespace std;class Shape &#123;public: Shape(); ~Shape(); double calcArea();&#125;;class Circle : Shape &#123;public: Circle(int r); ~Circle();protected: int m_r;&#125;;Circle::Circle(int r) &#123; m_r = r;&#125;Circle::~Circle() &#123;&#125;Shape::Shape() &#123;&#125;Shape::~Shape() &#123;&#125;double Shape::calcArea() &#123;&#125;int main() &#123; Shape shape; cout &lt;&lt; sizeof(shape) &lt;&lt; endl; Circle circle(100); cout &lt;&lt; sizeof(circle) &lt;&lt; endl; //一个int占4位 //计算机位数不同，位数显示的不一样 //64位计算机显示指针占8位 return 0;&#125;输出结果：121 //如果对象 没有任何数据，1代表一个占位符，代表是一个对象4 //对象有成员数据的话，就显示成员数据占据的大小。被virtual修饰后123456789101112131415161718192021222324#include &lt;iostream&gt;/** * C++虚构函数和虚函数指针的原理 */using namespace std;class Shape &#123;public: Shape(); ~Shape(); virtual double calcArea(); //被virtual修饰后 包含一个虚函数表 虚函数表也是一个指针类型 4位&#125;;int main() &#123; Shape shape; cout &lt;&lt; sizeof(shape) &lt;&lt; endl; Circle circle(100); cout &lt;&lt; sizeof(circle) &lt;&lt; endl; return 0;&#125;输出结果：123//电脑是64位的，显示的结果不太一样816 //int 4为位，虚函数表8位， 显示16 可能是自动补齐验证是否有虚函数表存在：12345678910111213Shape shape; cout &lt;&lt; sizeof(shape) &lt;&lt; endl; //&amp;shape 取得地址符是 Shape类型的指针，要它强转为int指针 int *p = (int *) &amp;shape; cout &lt;&lt; (unsigned int) (*p) &lt;&lt; endl; Circle circle(100); cout &lt;&lt; sizeof(circle) &lt;&lt; endl; int *q=(int*)&amp;circle; cout &lt;&lt; (unsigned int) (*q) &lt;&lt; endl; q++;//64位系统 每一次++只前进4位 所以要加两次 q++; cout &lt;&lt; (unsigned int) (*q) &lt;&lt; endl; return 0;输出结果：1234584206848 //地址值164206880 //地址值100 //int的值","categories":[],"tags":[]},{"title":"WEB前端 CSS选择器","slug":"yuque/oxz24f","date":"2019-03-18T09:55:17.000Z","updated":"2019-04-03T03:18:11.624Z","comments":true,"path":"2019/03/18/yuque/oxz24f/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/oxz24f/","excerpt":"","text":"WEB前端-CSS选择器(CSS背景)交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器注：用的相对来说比较少，不太建议使用。123h3.title&#123;color:red;&#125;标签下的类名：h3标签下类名叫title并集选择器如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式1比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。子元素选择器子元素选择器: 拥有父类的元素称为子元素1.demo &gt; h3 &#123;color: red;&#125; 类名demo下的子标签h3标签属性选择器选取标签带有某些特殊属性的选择器12345678910/* 获取到 拥有 该属性的元素 */div[class^=font] &#123; /* class^=font 表示 font 开始位置就行了 */ color: pink; &#125;div[class$=footer] &#123; /* class$=footer 表示 footer 结束位置就行了 */ color: skyblue; &#125;div[class*=tao] &#123; /* class*=tao *= 表示tao 在任意位置都可以 */ color: green; &#125;1234567891011&lt;div class=\"font12\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"font12\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"font24\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"font24\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"font24\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"24font\"&gt;属性选择器123&lt;/div&gt; &lt;div class=\"sub-footer\"&gt;属性选择器footer&lt;/div&gt; &lt;div class=\"jd-footer\"&gt;属性选择器footer&lt;/div&gt; &lt;div class=\"news-tao-nav\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"news-tao-header\"&gt;属性选择器&lt;/div&gt; &lt;div class=\"tao-header\"&gt;属性选择器&lt;/div&gt;伪元素选择器（CSS3)E::first-letter文本的第一个单词或字（如中文、日文、韩文等）E::first-line 文本第一行；E::selection 可改变选中文本的样式；E::before和E::after在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。1234567891011121314151617181920p::first-letter &#123; font-size: 20px; color: hotpink;&#125;/* 首行特殊样式 */p::first-line &#123; color: skyblue;&#125;p::selection &#123; /* font-size: 50px; */ color: orange;&#125;div::befor &#123; content:\"开始\";&#125;div::after &#123; content:\"结束\";&#125;CSS背景背景透明(CSS3)CSS3支持背景半透明的写法语法格式是:1background: rgba(0,0,0,0.3);最后一个参数是alpha 透明度 取值范围 0~1之间注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。其参数设置如下：a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。1234background-image: url('images/gyt.jpg'); background-size: 300px 100px; /* background-size: contain; */ /* background-size: cover; */多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 做法就是 用逗号隔开就好了。一个元素可以设置多重背景图像。每组属性间使用逗号分隔。如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。为了避免背景色将图像盖住，背景色通常都定义在最后一组上，123background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px , url(test1.jpg) no-repeat scroll 10px 20px/70px 90px , url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa;凹凸文字12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; div &#123; color: #ccc; font: 700 80px \"微软雅黑\"; &#125; div:first-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: 1px 1px 1px #000, -1px -1px 1px #fff; &#125; div:last-child &#123; /* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */ text-shadow: -1px -1px 1px #000, 1px 1px 1px #fff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是凸起的文字&lt;/div&gt; &lt;div&gt;我是凹下的文字&lt;/div&gt; &lt;/body&gt;CSS 三大特性CSS层叠性所谓层叠性是指多种CSS样式的叠加。一般情况下，按照CSS顺序，以最后的样式为准。样式冲突，遵循的原则是就近原则。CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号注：子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）CSS优先级继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。继承或者* 的贡献值0,0,0,0每个元素（标签）贡献值为0,0,0,1每个类，伪类贡献值为0,0,1,0每个ID贡献值为0,1,0,0每个行内样式贡献值1,0,0,0每个!important贡献值∞ 无穷大权重是可以叠加的例子：123456789div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,112345678910111213总结优先级：使用了 !important声明的规则。内嵌在 HTML 元素的 style属性里面的声明。使用了 ID 选择器的规则。使用了类选择器、属性选择器、伪元素和伪类选择器的规则。使用了元素选择器的规则。只包含一个通用选择器的规则。同一类选择器则遵循就近原则。注意： 继承的 权重是 0数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0。","categories":[],"tags":[]},{"title":"WEB前端 盒子模型初识","slug":"yuque/ir3uw4","date":"2019-03-18T09:55:00.000Z","updated":"2019-04-03T03:18:11.625Z","comments":true,"path":"2019/03/18/yuque/ir3uw4/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/ir3uw4/","excerpt":"","text":"CSS 框模型概述元素内是要展示的内容，里面的padding、margin、border都会参与计算盒子的大小，例如：有一个盒子大小为100px，外边距10px，内边距5px，实际要展示的内容只有70px为了更方便地控制网页中的元素，最好清除元素的默认内外边距：1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125;content宽度和高度计算使用宽度属性width和高度属性height可以对盒子的大小进行控制。width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：123456/*外盒尺寸计算（元素空间尺寸）*/ Element空间高度 = content height + padding + border + margin Element 空间宽度 = content width + padding + border + margin /*内盒尺寸计算（元素实际大小）*/ Element Height = content height + padding + border （Height为内容高度） Element Width = content width + padding + border （Width为内容宽度）注意：1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。3、如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小。盒子边框（border）1border : border-width || border-style || border-color边框属性—设置边框样式（border-style）边框样式用于定义页面中边框的风格，常用属性值如下：123456789none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线 dotted：边框为点线double：边框为双实线盒子边框写法总结表设置内容样式属性常用属性值上边框border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色;下边框border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色;左边框border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色;右边框border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色;样式综合设置border-style:上边 [右边 下边 左边];none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线宽度综合设置border-width:上边 [右边 下边 左边];像素值颜色综合设置border-color:上边 [右边 下边 左边];颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)边框综合设置border:四边宽度 四边样式 四边颜色;表格的细线边框表格线变粗原因是因为边框重叠table{ border-collapse:collapse; } collapse 单词是合并的意思border-collapse:collapse; 表示边框合并在一起。圆角边框(CSS3)语法格式：1border-radius: 左上角 右上角 右下角 左下角;案例:123456789101112131415161718192021222324252627282930313233&lt;style&gt; div &#123; width: 200px; height: 200px; border: 1px solid red; &#125; div:first-child &#123; /* 结构伪类选择器 选亲兄弟 */ border-radius: 10px; /* 一个数值表示4个角都是相同的 10px 的弧度 */ &#125; div:nth-child(2) &#123; /*border-radius: 100px; 取宽度和高度 一半 则会变成一个圆形 */ border-radius: 50%; /* 100px 50% 取宽度和高度 一半 则会变成一个圆形 */ &#125; div:nth-child(3) &#123; border-radius: 10px 40px; /* 左上角 和 右下角 是 10px 右上角 左下角 40 对角线 */ &#125; div:nth-child(4) &#123; border-radius: 10px 40px 80px; /* 左上角 10 右上角 左下角 40 右下角80 */ &#125; div:nth-child(5) &#123; border-radius: 10px 40px 80px 100px; /* 左上角 10 右上角 40 右下角 80 左下角 右下角100 */ &#125; div:nth-child(6) &#123; border-radius: 100px; height: 100px; &#125; div:nth-child(7) &#123; border-radius: 100px 0; &#125; &lt;/style&gt;内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。padding-top:上内边距padding-right:右内边距padding-bottom:下内边距padding-left:左内边距值的个数表达意思1个值padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素2个值padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素3个值padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素4个值padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。margin-top:上外边距margin-right:右外边距margin-bottom:下外边距margin-left:上外边距margin:上外边距 右外边距 下外边距 左外边取值顺序跟内边距相同。外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件：必须是块级元素。盒子必须指定了宽度（width）然后就给左右的外边距都设置为auto，就可使块级元素水平居中。实际工作中常用这种方式进行网页布局，示例代码如下：1.header&#123; width:960px; margin:0 auto;&#125;文字盒子居中图片和背景区别文字水平居中是 text-align: center盒子水平居中 左右margin 改为 auto12text-align: center; /* 文字居中水平 */margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */插入图片 我们用的最多 比如产品展示类背景图片我们一般用于小图标背景 或者 超大背景图片12345678910111213141516section img &#123; width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */ &#125;aside &#123; width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-size: 200px 210px; /* 背景图片更改大小只能用 background-size */ background-position: 30px 50px; /* 背景图片更该位置 我用 background-position */ &#125;外边距合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。外边距遇到另一个元素的外边距，它还会发生合并：解决方案###","categories":[],"tags":[]},{"title":"RSA+AES请求组合加密","slug":"yuque/whdmw7","date":"2019-03-18T09:53:58.000Z","updated":"2019-04-03T03:18:11.626Z","comments":true,"path":"2019/03/18/yuque/whdmw7/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/whdmw7/","excerpt":"","text":"基本概念加密方式分为：AES(对称加密)和RSA(非对称加密)AES算法流程发送方：创建AES私钥，用口令对私钥加密将加密后的私钥发送给接收方用私钥加密明文，并将密文和加密后的私钥发给接收方接收方：解密这个私钥用解密后的密钥把密文解密成明文RSA算法流程接收方：创建RSA密钥对（公钥和私钥）公钥发给发送方，私钥存在接收方。接收方用私钥对密文解密发送方：公钥对明文加密，将密文发给接收方RSA+AES结合加密接收方：创建RSA密钥对（公钥、私钥）把公钥发给发送方，自己保存私钥用RSA私钥解密加密后的AES密钥，并用AES密钥解密密文，得到明文发送方：创建AES密钥，并用AES加密明文，再用RSA公钥加密AES密钥，并把加密后的AES密钥和密文发送给接收方Android RSA+AES加密过程Android：生成AES密钥，并用AES密钥对明文加密使用RSA公钥将AES密钥(aesKey)加密成encryptAesKey，作为HTTP请求头将AES加密明文后的密文（encryptData）作为请求体，将请求体和请求头一起发给seversever：生成RSA密钥对（公钥、私钥）,提供接口给客户端，发送公钥获得AES加密后的请求头（encryptAesKey），获得加密后的请求体（encryptData）使用私钥解密请求头请求头（encryptAesKey）获得到AES密钥去请求体（encryptData）里的密文参考链接我的Android进阶之旅——&gt;Android采用AES+RSA的加密机制对http请求进行加密Android数据加密之RSA+AES混合加密Android数据加密之Aes加密","categories":[],"tags":[]},{"title":"Android事件传递机制","slug":"yuque/ph7ndd","date":"2019-03-18T09:53:18.000Z","updated":"2019-04-03T03:18:11.627Z","comments":true,"path":"2019/03/18/yuque/ph7ndd/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/ph7ndd/","excerpt":"","text":"事件传递要经的方法123public boolean dispatchTouchEvent(MotionEvent ev); //分发事件public boolean onInterceptTouchEvent(MotionEvent ev); //拦截事件public boolean onTouchEvent(MotionEvent ev); //处理事件事件传递的简介ViewGroup接收事件后，进行分发：如果不进行分发，则dispatchTouchEvent返回true，事件消亡未处理。如果进行分发该事件，则dispatchTouchEvent返回false，处理或传递该事件：如果想自己处理该事件,则onInterceptTouchEvent返回true，拦截事件，给自己的onTouchEvent进行处理；如果不想处理该事件，则onInterceptTouchEvent返回false，把事件传递给子View进行处理。对于最底层的子View，没有onInterceptEvent拦截事件，接收到事件后进行分发：如果不进行分发，则dispatchTouchEvent返回false，事件未处理，注意这里的最小子view返回false代表未分发事件；如果进行分发该事件，则dispatchTouchEvent返回true：如果处理该事件，则onTouchEvent返回true把该事件消费掉；如果不想处理该事件，则onTouchEvent返回false，等待上级处理。需要注意：viewGroup中包含的最小子view是不含拦截onInterceptTouchEvent事件的，最小的子view比如Button,TextView…因为他们已在树的最底层，已无法向下传递了。","categories":[],"tags":[]},{"title":"Kotlin基本数据类型","slug":"yuque/bzavq1","date":"2019-03-18T09:51:53.000Z","updated":"2019-04-03T03:18:11.628Z","comments":true,"path":"2019/03/18/yuque/bzavq1/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/bzavq1/","excerpt":"","text":"Kotlin数据类型typeBitDouble64Float32Long64Int32Short16Byte8Kotlin八大数组类型TypeCharArrayByteArrayShortArrayIntArrayFloatArrayDoubleArray1常量 定义：val FINAL_HELLO_WORLD: String = \"Hello World\" //val1变量定义：var text: String = hello //var1var text: String? = helloWorld //String 类型1val textArray: Array&lt;Char&gt; = arrayOf('H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd') // Char 字符数组1val helloWorldCharArray: CharArray = charArrayOf('H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd') //Kotlin 类型的字符数组1val helloWorldLength: Int = helloWorld.length //字符长度 int类型1val helloWorldLengthLong: Long = helloWorldLength.toLong() //字符长度转换为Long 类型","categories":[],"tags":[]},{"title":"const与基本数据类型","slug":"yuque/ugsunf","date":"2019-03-18T09:51:36.000Z","updated":"2019-04-03T03:18:11.628Z","comments":true,"path":"2019/03/18/yuque/ugsunf/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/ugsunf/","excerpt":"","text":"const修饰符const与基本数据类型const int x=3； //常量变量名存储地址存储内容x&amp;x3（不可更改的值）const与指针类型对号 代表等价 const int *p =NULL ； int const *p=NuLL; int* const p=NULL； const int* const p=NULL; int const* const p=NULL;例子：int x=3; const int *p=&amp;x;p=&amp;y;正确 *p=4；错误因为const修饰的是_p而不是p，所以p可以更改值，而 _p不能更改值。变量名存储地址存储内容x&amp;x3p&amp;p&amp;xconst修饰符修饰谁，谁就不能变。内存的申请和释放申请内存运算符关键词 new detle","categories":[],"tags":[]},{"title":"Git命令","slug":"yuque/qbu9z0","date":"2019-03-18T09:49:54.000Z","updated":"2019-04-03T03:18:11.629Z","comments":true,"path":"2019/03/18/yuque/qbu9z0/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/qbu9z0/","excerpt":"","text":"生成ssh私钥123$ git config --list //查看当前全局配置$ git config --global user.name &quot;用户名&quot;$ git config --global user.email &quot;邮箱&quot;生成ssh密钥：1$ ssh-keygen -t rsa -C “邮箱”克隆项目1git clone","categories":[],"tags":[]},{"title":"C++ RTTI","slug":"yuque/fqaa2q","date":"2019-03-18T09:49:02.000Z","updated":"2019-04-03T03:18:11.630Z","comments":true,"path":"2019/03/18/yuque/fqaa2q/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/fqaa2q/","excerpt":"","text":"RTTI（Run-Time Type Identification)运行时类型识别，类似JAVA中的多态父类接口类：12345class Person &#123;public: virtual void eat()=0; virtual void run()=0;&#125;;子类实现1234567891011121314151617181920212223242526272829303132//继承并实现class Teacher : public Person &#123;public: void Study(); virtual void eat(); virtual void run();&#125;;class Student : public Person &#123;public: void play(); virtual void eat(); virtual void run();&#125;;//.cpp 实现void Teacher::run() &#123; cout &lt;&lt; \"Teacher::run()\" &lt;&lt; endl;&#125;void Teacher::eat() &#123; cout &lt;&lt; \"Teacher::eat()\" &lt;&lt; endl;&#125;void Teacher::Study() &#123; cout &lt;&lt; \"Teacher::Study()\" &lt;&lt; endl;&#125;void Student::run() &#123; cout &lt;&lt; \"Student::run()\" &lt;&lt; endl;&#125;void Student::eat() &#123; cout &lt;&lt; \"Student::eat()\" &lt;&lt; endl;&#125;void Student::play() &#123; cout &lt;&lt; \"Student::play()\" &lt;&lt; endl;&#125;123456789101112131415161718void Test(Person *obj) &#123; cout &lt;&lt; typeid(*obj).name() &lt;&lt; endl; obj-&gt;run(); if (typeid(*obj) == typeid(Student)) &#123; Student *student = dynamic_cast&lt;Student *&gt;(obj); student-&gt;play(); &#125; if (typeid(*obj) == typeid(Teacher)) &#123; Teacher *teacher = dynamic_cast&lt;Teacher *&gt;(obj); teacher-&gt;Study(); &#125; obj-&gt;eat();&#125;int main() &#123; Student student; Test(&amp;student); return 0;&#125;结果：12347StudentStudent::run()Student::play()Student::eat()类型转换：如果子类必须含有虚函数，否则不是多态，其次，必须事引用和指针才能类型转换如下：123456//父类去掉纯虚函数class Person &#123;public: void eat(); void run();&#125;;1234567//子类没有虚函数class Student : public Person &#123;public: void play(); void eat(); void run();&#125;;123456int main() &#123; Person *person = new Student(); //子类必须含有虚函数，否则不是多态。其次，必须是引用和指针才能类型转换 Student *s = dynamic_cast&lt;Student *&gt;(person); //直接报错，错误原因是：person 不是多态类型 return 0;&#125;","categories":[],"tags":[]},{"title":"C++ STL标准模板库","slug":"yuque/dggnmz","date":"2019-03-18T09:48:36.000Z","updated":"2019-04-03T03:18:11.630Z","comments":true,"path":"2019/03/18/yuque/dggnmz/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/dggnmz/","excerpt":"","text":"C++ STL（标准模板库）C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。C++ 标准模板库的核心包括以下三个组件：组件描述容器（Containers）容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。算法（Algorithms）算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。迭代器（iterators）迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。例子:1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; int main()&#123; // 创建一个向量存储 int vector&lt;int&gt; vec; int i; // 显示 vec 的原始大小 cout &lt;&lt; \"vector size = \" &lt;&lt; vec.size() &lt;&lt; endl; // 推入 5 个值到向量中 for(i = 0; i &lt; 5; i++)&#123; vec.push_back(i); &#125; // 显示 vec 扩展后的大小 cout &lt;&lt; \"extended vector size = \" &lt;&lt; vec.size() &lt;&lt; endl; // 访问向量中的 5 个值 for(i = 0; i &lt; 5; i++)&#123; cout &lt;&lt; \"value of vec [\" &lt;&lt; i &lt;&lt; \"] = \" &lt;&lt; vec[i] &lt;&lt; endl; &#125; // 使用迭代器 iterator 访问值 vector&lt;int&gt;::iterator v = vec.begin(); while( v != vec.end()) &#123; cout &lt;&lt; \"value of v = \" &lt;&lt; *v &lt;&lt; endl; v++; &#125; return 0;&#125;输出结果：123456789101112vector size = 0extended vector size = 5value of vec [0] = 0value of vec [1] = 1value of vec [2] = 2value of vec [3] = 3value of vec [4] = 4value of v = 0value of v = 1value of v = 2value of v = 3value of v = 4关于上面实例中所使用的各种函数，有几点要注意：push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。size( ) 函数显示向量的大小。begin( ) 函数返回一个指向向量开头的迭代器。end( ) 函数返回一个指向向量末尾的迭代器。","categories":[],"tags":[]},{"title":"C++ 模板函数","slug":"yuque/qkf8tp","date":"2019-03-18T09:46:43.000Z","updated":"2019-04-03T03:18:11.631Z","comments":true,"path":"2019/03/18/yuque/qkf8tp/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/qkf8tp/","excerpt":"","text":"C++模板函数类似JAVA中的泛型，可以实例化多种参数类型的模板12345678910111213141516171819202122template &lt;typename T&gt; //typename 和 class 都是一样的void display(T a)&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;template &lt;typename T,class S&gt;void display(T t,S s)&#123; cout&lt;&lt;t&lt;&lt;endl; cout&lt;&lt;s&lt;&lt;endl;&#125;;template &lt;typename T, int Ksize&gt;void display(T a)&#123; for (int i = 0; i &lt; Ksize; ++i) &#123; cout&lt;&lt;a&lt;&lt;endl; &#125;&#125;;int main() &#123;// display&lt;int&gt;(10.89); //显示调用 display(10,29.2); return 0; &#125;","categories":[],"tags":[]},{"title":"C++ 虚函数","slug":"yuque/rzuyu3","date":"2019-03-18T09:46:15.000Z","updated":"2019-04-03T03:18:11.631Z","comments":true,"path":"2019/03/18/yuque/rzuyu3/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/rzuyu3/","excerpt":"","text":"C++虚函数父类函数不加virtual关键词，子类继承后，当父类指针指向子类指针，同样的函数，会执行父类的函数。子类的函数实际是被隐藏了，如果用子类的指针指向自己的话，是能够执行的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;/** * C++多态 虚函数 */using namespace std;class Shape &#123;public: Shape(); ~Shape(); double calcArea();&#125;;class Circle : public Shape &#123;public: Circle(double r); ~Circle(); double calcArea();protected: double m_dR;protected: string m_strName;&#125;;class Rect : public Shape &#123;public: Rect(double width, double height); ~Rect(); double calcArea();protected: double m_dWidth; double m_dHeight;&#125;;Rect::Rect(double width, double height) &#123; m_dHeight = height; m_dWidth = width; cout &lt;&lt; \"Rect::Rect()\" &lt;&lt; endl;&#125;double Rect::calcArea() &#123; cout &lt;&lt; \"Rect::calcArea()\" &lt;&lt; endl; return m_dWidth*m_dHeight;&#125;Rect::~Rect() &#123; cout &lt;&lt; \"~Rect()\" &lt;&lt; endl;&#125;Circle::Circle(double r) &#123; m_dR = r; cout &lt;&lt; \"Circle()\" &lt;&lt; endl;&#125;double Circle::calcArea() &#123; cout &lt;&lt; \"Circle::calcArea()\" &lt;&lt; endl; return 3.14 * m_dR * m_dR;&#125;Circle::~Circle() &#123; cout &lt;&lt; \"~Circle()\" &lt;&lt; endl;&#125;Shape::Shape() &#123; cout &lt;&lt; \"Shape()\" &lt;&lt; endl;&#125;Shape::~Shape() &#123; cout &lt;&lt; \"~Shape()\" &lt;&lt; endl;&#125;double Shape::calcArea() &#123; cout &lt;&lt; \"Shape::clacArea()\" &lt;&lt; endl;&#125;int main() &#123; Shape *shape=new Rect(3,6); Shape *shape1=new Circle(5); shape-&gt;calcArea(); shape1-&gt;calcArea(); delete(shape); delete(shape1); return 0;&#125;运行的结果12345678Shape()Rect::Rect()Shape()Circle()Shape::clacArea() //父类的方法Shape::clacArea() //父类的方法~Shape()~Shape()加上virtual关键词后123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;/** * C++多态 虚函数 */using namespace std;class Shape &#123;public: Shape(); ~Shape(); virtual double calcArea();&#125;;//虚继承class Circle : public Shape &#123;public: Circle(double r); ~Circle(); double calcArea();protected: double m_dR;protected: string m_strName;&#125;;//虚继承class Rect : public Shape &#123;public: Rect(double width, double height); ~Rect(); double calcArea();protected: double m_dWidth; double m_dHeight;&#125;;Rect::Rect(double width, double height) &#123; m_dHeight = height; m_dWidth = width; cout &lt;&lt; \"Rect::Rect()\" &lt;&lt; endl;&#125;double Rect::calcArea() &#123; cout &lt;&lt; \"Rect::calcArea()\" &lt;&lt; endl; return m_dWidth*m_dHeight;&#125;Rect::~Rect() &#123; cout &lt;&lt; \"~Rect()\" &lt;&lt; endl;&#125;Circle::Circle(double r) &#123; m_dR = r; cout &lt;&lt; \"Circle()\" &lt;&lt; endl;&#125;double Circle::calcArea() &#123; cout &lt;&lt; \"Circle::calcArea()\" &lt;&lt; endl; return 3.14 * m_dR * m_dR;&#125;Circle::~Circle() &#123; cout &lt;&lt; \"~Circle()\" &lt;&lt; endl;&#125;Shape::Shape() &#123; cout &lt;&lt; \"Shape()\" &lt;&lt; endl;&#125;Shape::~Shape() &#123; cout &lt;&lt; \"~Shape()\" &lt;&lt; endl;&#125;double Shape::calcArea() &#123; cout &lt;&lt; \"Shape::clacArea()\" &lt;&lt; endl;&#125;int main() &#123; Shape *shape=new Rect(3,6); Shape *shape1=new Circle(5); shape-&gt;calcArea(); shape1-&gt;calcArea(); delete(shape); delete(shape1); return 0;&#125;运行结果12345678Shape()Rect::Rect()Shape()Circle()Rect::calcArea() //子类自己的函数Circle::calcArea()//子类自己的函数~Shape()~Shape()","categories":[],"tags":[]},{"title":"C++ 虚析构函数","slug":"yuque/yk01ls","date":"2019-03-18T09:45:47.000Z","updated":"2019-04-03T03:18:11.632Z","comments":true,"path":"2019/03/18/yuque/yk01ls/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/yk01ls/","excerpt":"","text":"C++虚析构函数防止内存泄露子类继承父类后，在子类构造函数里，通过new 来生成一个对象实例在析构函数里执行释放内存操作，如果父类不加上virtual 关键词则子类执行的是父类的析构函数，不执行自己的析构函数。父类不加virtual 子类继承后，并执行析构函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;/** * C++多态 虚析构函数 （防止内存泄露） */using namespace std;//形状class Shape &#123;public: Shape(); ~Shape(); virtual double calcArea();&#125;;class Coordinate &#123;public: Coordinate(int x, int y); ~Coordinate();protected: int m_iX; int m_iY;&#125;;//Circle继承Shapeclass Circle : public Shape &#123;public: Circle(double r); ~Circle(); double calcArea();protected: double m_dR; Coordinate *coordinate;protected: string m_strName;&#125;;//Rect继承Shapeclass Rect : public Shape &#123;public: Rect(double width, double height); ~Rect(); double calcArea();protected: double m_dWidth; double m_dHeight;&#125;;Coordinate::Coordinate(int x, int y) &#123; cout &lt;&lt; \"Coordinate()\" &lt;&lt; endl; m_iX = x; m_iY = y;&#125;Coordinate::~Coordinate() &#123; cout &lt;&lt; \"~Coordinate()\" &lt;&lt; endl;&#125;Rect::Rect(double width, double height) &#123; m_dHeight = height; m_dWidth = width; cout &lt;&lt; \"Rect::Rect()\" &lt;&lt; endl;&#125;double Rect::calcArea() &#123; cout &lt;&lt; \"Rect::calcArea()\" &lt;&lt; endl; return m_dWidth * m_dHeight;&#125;Rect::~Rect() &#123; cout &lt;&lt; \"~Rect()\" &lt;&lt; endl;&#125;Circle::Circle(double r) &#123; m_dR = r; coordinate=new Coordinate(5,5); cout &lt;&lt; \"Circle()\" &lt;&lt; endl;&#125;double Circle::calcArea() &#123; cout &lt;&lt; \"Circle::calcArea()\" &lt;&lt; endl; return 3.14 * m_dR * m_dR;&#125;Circle::~Circle() &#123; delete(coordinate);//释放内存 cout &lt;&lt; \"~Circle()\" &lt;&lt; endl;&#125;Shape::Shape() &#123; cout &lt;&lt; \"Shape()\" &lt;&lt; endl;&#125;Shape::~Shape() &#123; cout &lt;&lt; \"~Shape()\" &lt;&lt; endl;&#125;double Shape::calcArea() &#123; cout &lt;&lt; \"Shape::clacArea()\" &lt;&lt; endl;&#125;int main() &#123; Shape *shape = new Rect(3, 6); Shape *shape1 = new Circle(5); shape-&gt;calcArea(); shape1-&gt;calcArea(); delete (shape); //释放内存 delete (shape1);//释放内存 return 0;&#125;输出结果：123456789Shape()Rect::Rect()Shape()Coordinate()Circle()Rect::calcArea()Circle::calcArea()~Shape() //父类析构被执行了两次~Shape() //父类析构被执行了两次父类加上virtual关键词后，子类执行析构函数：123456789class Shape &#123;public: Shape(); virtual ~Shape(); //父类加上virtual virtual double calcArea();&#125;;输出结果：123456789101112Shape()Rect::Rect()Shape()Coordinate()Circle()Rect::calcArea()Circle::calcArea()~Rect() //子类析构函数被执行~Shape()~Coordinate() //子类析构函数被执行~Circle() //子类析构函数被执行~Shape()virtual关键词限制1.普通函数不能被修饰（类外面单独提供的方法）2.静态成员不能被修饰3.内联函数不能被修饰（会导致内联函数失效）","categories":[],"tags":[]},{"title":"C++ 友元","slug":"yuque/xcz284","date":"2019-03-18T09:45:21.000Z","updated":"2019-04-03T03:18:11.633Z","comments":true,"path":"2019/03/18/yuque/xcz284/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/xcz284/","excerpt":"","text":"C++友元友元函数：1234567891011class Time &#123; friend void printTime(Time &amp;t);public: Time(int hour, int min, int sec);private: int m_hour; int m_min; int m_sec;&#125;;12345Time::Time(int hour, int min, int sec) &#123; m_hour=hour; m_min=min; m_sec=sec;&#125;测试：123456789void printTime(Time &amp;t)&#123; cout &lt;&lt;t.m_hour&lt;&lt;\":\"&lt;&lt;t.m_min&lt;&lt;\":\"&lt;&lt;t.m_sec&lt;&lt;endl;&#125;int main() &#123; Time t(4,5,6) ; printTime(t); return 0;&#125;友元类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;typeinfo&gt;/** * 友元函数 */using namespace std;class Match;class Time &#123; friend Match;//友元类的声明public: Time(int hour, int min, int sec);private: void printTime(); int m_hour; int m_min; int m_sec;&#125;;class Match &#123;public: Match(int hour, int min, int sec); void testTime();private: Time m_timer; int m_hour; int m_min; int m_sec;&#125;;Time::Time(int hour, int min, int sec) &#123; m_hour = hour; m_min = min; m_sec = sec;&#125;void Time::printTime() &#123; cout &lt;&lt; m_hour &lt;&lt; \":\" &lt;&lt; m_min &lt;&lt; \":\" &lt;&lt; m_sec &lt;&lt; endl;&#125;Match::Match(int hour, int min, int sec) : m_timer(hour, min, sec) &#123;&#125;void Match::testTime() &#123; m_timer.printTime(); cout &lt;&lt; m_hour &lt;&lt; \":\" &lt;&lt; m_min &lt;&lt; \":\" &lt;&lt; m_sec &lt;&lt; endl;&#125;int main() &#123; Match m(5, 43, 33); m.testTime(); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 运算符重载","slug":"yuque/cson21","date":"2019-03-18T09:44:54.000Z","updated":"2019-04-03T03:18:11.636Z","comments":true,"path":"2019/03/18/yuque/cson21/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/cson21/","excerpt":"","text":"C++ 运算符重载运算符重载关键词operator相当于可以把运算符 重新定义为新的运算逻辑，例如之前的+ 号可以 运算int类型如果重载这个+号，可以实现两个对象相加。例子一：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//.h 声明//纯虚函数 只是头文件 没有cpp，没有实现类class Person&#123; friend Person &amp;operator-(Person &amp;p); //友元运算符重载public: Person(int x ,int y);// Person &amp;operator-();//运算符重载 int getX(); int getY();private: int m_iX; int m_iY;&#125;;//cpp 这叫定义Person::Person(int x, int y) &#123; m_iX=x; m_iY=y;&#125;int Person::getX() &#123; return m_iX;&#125;int Person::getY() &#123; return m_iY;&#125;Person&amp; operator-(Person &amp;p) &#123; p.m_iY=-p.m_iY; p.m_iX=-p.m_iX; return p;&#125;//运算符重载//Person&amp; Person::operator-() &#123;// this-&gt;m_iX=-(this-&gt;m_iX);// m_iY=-m_iY;// return *this;//&#125;int main() &#123; Person p(1,2); cout&lt;&lt;p.getY()&lt;&lt;endl; cout&lt;&lt;p.getX()&lt;&lt;endl; -p; cout&lt;&lt;p.getY()&lt;&lt;endl; cout&lt;&lt;p.getX()&lt;&lt;endl; return 0;&#125;例子二：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374include &lt;iostream&gt;using namespace std; class Box&#123; public: double getVolume(void) &#123; return length * breadth * height; &#125; void setLength( double len ) &#123; length = len; &#125; void setBreadth( double bre ) &#123; breadth = bre; &#125; void setHeight( double hei ) &#123; height = hei; &#125; // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; private: double length; // 长度 double breadth; // 宽度 double height; // 高度&#125;;// 程序的主函数int main( )&#123; Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout &lt;&lt; \"Volume of Box1 : \" &lt;&lt; volume &lt;&lt;endl; // Box2 的体积 volume = Box2.getVolume(); cout &lt;&lt; \"Volume of Box2 : \" &lt;&lt; volume &lt;&lt;endl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout &lt;&lt; \"Volume of Box3 : \" &lt;&lt; volume &lt;&lt;endl; return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 类模板","slug":"yuque/cnuhh0","date":"2019-03-18T09:43:09.000Z","updated":"2019-04-03T03:18:11.637Z","comments":true,"path":"2019/03/18/yuque/cnuhh0/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/cnuhh0/","excerpt":"","text":"C++类模板类模板 函数声明和函数实现必须写一个文件里实现的函数，必须加上template这样的定义12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//.h 声明template&lt;typename T, int Ksiez, int Kval&gt;class Myarray &#123;public: Myarray(); ~Myarray() &#123; delete mpArr; &#125; void display();private: T *mpArr;&#125;;//cpp 这叫定义template&lt;typename T, int Ksiez, int Kval&gt;Myarray&lt;T, Ksiez, Kval&gt;::Myarray() &#123; mpArr = new T[Ksiez]; for (int i = 0; i &lt; Ksiez; ++i) &#123; mpArr[i] = Kval; &#125;&#125;template&lt;typename T, int Ksiez, int Kval&gt;void Myarray&lt;T,Ksiez,Kval&gt;::display() &#123; for (int i = 0; i &lt; Ksiez; ++i) &#123; cout&lt;&lt;mpArr[i]&lt;&lt;endl; &#125;&#125;int main() &#123; Myarray&lt;int,5,6&gt; myarray; myarray.display(); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 虚继承","slug":"yuque/zoa2yv","date":"2019-03-18T09:42:43.000Z","updated":"2019-04-03T03:18:11.638Z","comments":true,"path":"2019/03/18/yuque/zoa2yv/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/zoa2yv/","excerpt":"","text":"如果不虚继承的话，父类对象每一次被调用都会被初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;/** * C++多重继承 */using namespace std;class Person &#123;public: Person(string color=\"blue\"); virtual ~Person(); void printColor();protected: string m_strColor;&#125;;//虚继承class Farmer :virtual public Person&#123;public: Farmer(string name = \"jack\",string color=\"blue\"); ~Farmer(); void sow();protected: string m_strName;&#125;;//虚继承class Worker :virtual public Person&#123;public: Worker(string code = \"001\",string color=\"bule\"); virtual ~Worker(); void carry();protected: string m_strCode;&#125;;void Worker::carry() &#123; cout &lt;&lt; m_strCode &lt;&lt; endl; cout &lt;&lt; \"Worker::carry()\" &lt;&lt; endl;&#125;class MigrantWorker : public Farmer, public Worker &#123;public: MigrantWorker(string name, string age,string color); ~MigrantWorker();&#125;;Person::Person(string color) &#123; m_strColor=color; cout &lt;&lt; \"Person()\" &lt;&lt; endl;&#125;void Person::printColor() &#123; cout &lt;&lt; m_strColor &lt;&lt; endl; cout &lt;&lt; \"Person::printColor()\" &lt;&lt; endl;&#125;Person::~Person() &#123; cout &lt;&lt; \"~Person()\" &lt;&lt; endl;&#125;Farmer::Farmer(string name,string color):Person(color) &#123; m_strName = name; cout &lt;&lt; \"Farmer()\" &lt;&lt; endl;&#125;Farmer::~Farmer() &#123; cout &lt;&lt; \"~Farmer()\" &lt;&lt; endl;&#125;void Farmer::sow() &#123; cout &lt;&lt; m_strName &lt;&lt; endl; cout &lt;&lt; \"Farmer::sow()\" &lt;&lt; endl;&#125;Worker::~Worker() &#123; cout &lt;&lt; \"~Worker()\" &lt;&lt; endl;&#125;Worker::Worker(string code,string color):Person(color)&#123; m_strCode = code; cout &lt;&lt; \"Worker()\" &lt;&lt; endl;&#125;MigrantWorker::MigrantWorker(string name, string code,string color) : Farmer(name,color), Worker(code,color) &#123; cout &lt;&lt; \"MigrantWorker()\" &lt;&lt; endl;&#125;MigrantWorker::~MigrantWorker() &#123; cout &lt;&lt; \"~MigrantWorker()\" &lt;&lt; endl;&#125;int main() &#123; MigrantWorker *migrantWorker = new MigrantWorker(\"kitty\", \"002\",\"green\"); migrantWorker-&gt;carry(); migrantWorker-&gt;sow(); delete (migrantWorker); return 0;&#125;不加virtual关键词 输出结果123456789101112131415Person 被初始化了两次Person()Farmer()Person()Worker()MigrantWorker()002Worker::carry()kittyFarmer::sow()~MigrantWorker()~Worker()~Person()~Farmer()~Person()","categories":[],"tags":[]},{"title":"C++ 静态","slug":"yuque/yvurxt","date":"2019-03-18T09:42:12.000Z","updated":"2019-04-03T03:18:11.639Z","comments":true,"path":"2019/03/18/yuque/yvurxt/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/yvurxt/","excerpt":"","text":"C++静态（static）和JAVA中的静态差不多静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。使用静态数据成员可以节省内存,不占用内存，只有在实现的时候，才会占用内存声明静态成员的时候，需要加static关键词静态成员初始化，需要在实现里初始化，不能再头文件里初始化静态不能被const修饰，否则编译错误123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class StaticTest&#123;public: StaticTest(int a, int b, int c); void GetNumber(); void GetSum(); static void f1(StaticTest &amp;s); //静态函数private: int A, B, C; static int Sum; //静态成员数据&#125;;#include \"StaticTest.h\"#include &lt;iostream&gt;using namespace std;int StaticTest::Sum = 0;//静态成员在此初始化StaticTest::StaticTest(int a, int b, int c)&#123; A = a; B = b; C = c; Sum += A + B + C;&#125;void StaticTest::GetNumber()&#123; cout &lt;&lt; \"Number = \" &lt;&lt; endl;&#125;void StaticTest::GetSum()&#123; cout &lt;&lt; \"Sum = \" &lt;&lt; Sum &lt;&lt;endl;&#125;void StaticTest::f1(StaticTest &amp;s)&#123; cout &lt;&lt; s.A &lt;&lt; endl;//静态方法不能直接调用一般成员，可以通过对象引用实现调用 cout &lt;&lt; Sum &lt;&lt;endl;&#125;#include \"StaticTest.h\"#include &lt;stdlib.h&gt;int main(void)&#123; StaticTest M(3, 7, 10), N(14, 9, 11); M.GetNumber(); N.GetSum(); M.GetNumber(); N.GetSum(); StaticTest::f1(M); system(\"pause\"); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 接口类","slug":"yuque/xtdyib","date":"2019-03-18T09:41:32.000Z","updated":"2019-04-03T03:18:11.639Z","comments":true,"path":"2019/03/18/yuque/xtdyib/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/xtdyib/","excerpt":"","text":"C++接口类如果一个类里面只有纯虚函数，没有其他成员函数和数据成员，就是接口类。接口类：123456class Person &#123;public: virtual void eat()=0;//纯虚函数 virtual void run()=0;//纯虚函数&#125;;实现类：Teacher 继承自接口类Person，并实现Person纯虚函数12345678910111213141516171819202122232425//.h定义class Teacher :public Person&#123;public: virtual void eat(); virtual void run(); Teacher(string code); void printCode();protected: string m_strCode;&#125;;//.cpp 实现void Teacher::eat() &#123; cout&lt;&lt;\"Teacher::eat()\"&lt;&lt;endl;&#125;void Teacher::run() &#123; cout&lt;&lt;\"Teacher::run()\"&lt;&lt;endl;&#125;void Teacher::printCode() &#123; cout &lt;&lt; \"Teacher::printCode: \" &lt;&lt; m_strCode &lt;&lt; endl;&#125;Student类继承自Teacher，相当于有两个父类1234567891011121314151617181920212223//.h 定义class Student : public Teacher &#123;public: Student(string code); virtual void eat(); virtual void run();&#125;;//.cpp 实现void Student::run() &#123; cout &lt;&lt; \"Student::run()\" &lt;&lt; endl;&#125;Student::Student(string code) : Teacher(code) &#123; //列表参数初始化&#125;void Student::eat() &#123; cout &lt;&lt; \"Student::eat()\" &lt;&lt; endl;&#125;测试：123456789101112131415161718void personTest(Person *p1, Person *p2) &#123; p1-&gt;eat(); p1-&gt;run(); p2-&gt;eat(); p2-&gt;run();&#125;int main() &#123; Student p1(\"001\"); Student p2(\"002\"); p1.printCode(); p2.printCode(); personTest(&amp;p1, &amp;p2); return 0;&#125;输出结果：123456Teacher::printCode: 001Teacher::printCode: 002Student::eat()Student::run()Student::eat()Student::run()改进：让Student 有两个父类，多重继承12345678910class Teacher &#123; //Teacher 不继承接口类Personpublic: Teacher(string code); void printCode();protected: string m_strCode;&#125;;123456789class Student : public Teacher ,public Person&#123; //由Student类来继承自接口类，并实现public: Student(string code); virtual void eat(); virtual void run();&#125;;改进后测试:123456789101112131415void personTest(Teacher *p1, Teacher *p2) &#123; p1-&gt;printCode(); p2-&gt;printCode();&#125;int main() &#123; Student p1(\"001\"); Student p2(\"002\"); personTest(&amp;p1, &amp;p2); return 0;&#125;输出结果：12Teacher::printCode: 001Teacher::printCode: 002","categories":[],"tags":[]},{"title":"C++ 多重继承","slug":"yuque/nokfhz","date":"2019-03-18T09:36:35.000Z","updated":"2019-04-03T03:18:11.640Z","comments":true,"path":"2019/03/18/yuque/nokfhz/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/nokfhz/","excerpt":"","text":"C++多重继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;/** * C++多重继承 */using namespace std;class Farmer &#123;public: Farmer(string name = \"jack\"); ~Farmer(); void sow();protected: string m_strName;&#125;;class Worker &#123;public: Worker(string code = \"001\"); virtual ~Worker(); void carry();protected: string m_strCode;&#125;;void Worker::carry() &#123; cout &lt;&lt; m_strCode &lt;&lt; endl; cout &lt;&lt; \"Worker::carry()\" &lt;&lt; endl;&#125;class MigrantWorker : public Farmer, public Worker &#123;public: MigrantWorker(string name, string age); ~MigrantWorker();&#125;;Farmer::Farmer(string name) &#123; m_strName=name; cout &lt;&lt; \"Farmer()\" &lt;&lt; endl;&#125;Farmer::~Farmer() &#123; cout &lt;&lt; \"~Farmer()\" &lt;&lt; endl;&#125;void Farmer::sow() &#123; cout &lt;&lt; m_strName &lt;&lt; endl; cout &lt;&lt; \"Farmer::sow()\" &lt;&lt; endl;&#125;Worker::~Worker() &#123; cout &lt;&lt; \"~Worker()\" &lt;&lt; endl;&#125;Worker::Worker(string code) &#123; m_strCode = code; cout &lt;&lt; \"Worker()\" &lt;&lt; endl;&#125;//初始化列表的方式来初始化 name的值 和code 的值//类似：student::student( string name): m_name(name) 将有值的数据 传递给（）内的变量MigrantWorker::MigrantWorker(string name, string code) : Farmer(name), Worker(code) &#123; cout &lt;&lt; \"MigrantWorker()\" &lt;&lt; endl;&#125;MigrantWorker::~MigrantWorker() &#123; cout &lt;&lt; \"~MigrantWorker()\" &lt;&lt; endl;&#125;int main() &#123; MigrantWorker * migrantWorker=new MigrantWorker(\"kitty\",\"002\"); migrantWorker-&gt;carry(); migrantWorker-&gt;sow(); delete(migrantWorker); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 多继承","slug":"yuque/uy76br","date":"2019-03-18T09:21:53.000Z","updated":"2019-04-03T03:18:11.641Z","comments":true,"path":"2019/03/18/yuque/uy76br/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/uy76br/","excerpt":"","text":"C++多继承构造函数，先执行父类的构造函数依次执行，销毁对象，是按照初识化构造函数顺序，倒叙执行。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//.h 声明class Person &#123;public: void play(); Person(string name = \"kitty\"); virtual ~Person();protected: string m_strName;&#125;;class Soldier : public Person &#123;public: Soldier(string name = \"james\", int age = 20); void work(); virtual ~Soldier();protected: int m_iAge;&#125;;class Infantry : public Soldier &#123;public: Infantry(string name = \"jack\", int age = 30); void attack(); virtual ~Infantry();&#125;;//cpp 这叫定义void Person::play() &#123; cout &lt;&lt; \"Person::play()\" &lt;&lt; endl; cout &lt;&lt; m_strName &lt;&lt; endl;&#125;Person::~Person() &#123; cout &lt;&lt; \"~Person()\" &lt;&lt; endl;&#125;Person::Person(string name) &#123; m_strName = name; cout &lt;&lt; \"Person()\" &lt;&lt; endl;&#125;Soldier::Soldier(string name, int age) &#123; m_strName = name; m_iAge = age; cout &lt;&lt; \"Soldier()\" &lt;&lt; endl;&#125;Soldier::~Soldier() &#123; cout &lt;&lt; \"~Soldier()\" &lt;&lt; endl;&#125;void Soldier::work() &#123; cout &lt;&lt; m_strName &lt;&lt; endl; cout &lt;&lt; m_iAge &lt;&lt; endl; cout &lt;&lt; \"Soldier::work()\" &lt;&lt; endl;&#125;Infantry::Infantry(string name, int age) &#123; m_strName = name; m_iAge = age; cout &lt;&lt; \"Infantry()\" &lt;&lt; endl;&#125;Infantry::~Infantry() &#123; cout &lt;&lt; \"~Infantry()\" &lt;&lt; endl;&#125;void Infantry::attack() &#123; cout &lt;&lt; m_strName &lt;&lt; endl; cout &lt;&lt; m_iAge &lt;&lt; endl; cout &lt;&lt; \"Infantry::attack()\" &lt;&lt; endl;&#125;void test1(Person p) &#123; p.play();&#125;void test2(Person &amp;p) &#123; p.play();&#125;void test3(Person *p) &#123; p-&gt;play();&#125;int main() &#123; Infantry infantry; test1(infantry); test2(infantry); test3(&amp;infantry); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 继承 二","slug":"yuque/wn6k1b","date":"2019-03-18T09:21:18.000Z","updated":"2019-04-03T03:18:11.642Z","comments":true,"path":"2019/03/18/yuque/wn6k1b/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/wn6k1b/","excerpt":"","text":"C++隐藏父子关系，成员同名，才能隐藏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//.hclass Person &#123;public: void eat();protected: string m_strName; int m_iAge;private: string test;&#125;;class Worker : public Person &#123;public: void eat(); int m_iSalary;protected: string m_strName;private:&#125;;//cpp 这叫定义void Person::eat() &#123; cout&lt;&lt;\"Person::eat()\"&lt;&lt;endl;&#125;void Worker::eat() &#123; Person::m_strName=\"kitty\"; //访问父类的隐藏成员 cout&lt;&lt;\"Worker::eat()\"&lt;&lt;endl; cout&lt;&lt;Person::m_strName&lt;&lt;endl;&#125;int main() &#123; Person p; p.eat(); Worker w; w.Person::eat();//访问父类的隐藏函数 w.eat(); return 0;&#125;","categories":[],"tags":[]},{"title":"C++ 继承","slug":"yuque/dsybzb","date":"2019-03-18T09:20:46.000Z","updated":"2019-04-03T03:18:11.644Z","comments":true,"path":"2019/03/18/yuque/dsybzb/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/dsybzb/","excerpt":"","text":"C++继承公有(public)继承1234567891011121314151617class Person &#123;public: void eat();//public 权限protected: //protected 权限 string m_strName; int m_iAge;private://private权限 string test;&#125;;class Worker : public Person &#123;public: void work(); int m_iSalary;protected:private:&#125;;父类成员访问属性继承方式子类成员访问属性private成员public无法访问protected成员publicprotectedpublic成员publicpublic保护(protected)继承父类成员访问属性继承方式子类成员访问属性private成员protected无法访问protected成员protectedprotectedpublic成员protectedprotected私有(private)继承类成员访问属性继承方式子类成员访问属性private成员private无法访问protected成员privateprivatepublic成员privateprivate","categories":[],"tags":[]},{"title":"C++ 第二章","slug":"yuque/xnc8e7","date":"2019-03-18T09:16:01.000Z","updated":"2019-04-03T03:18:11.645Z","comments":true,"path":"2019/03/18/yuque/xnc8e7/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/xnc8e7/","excerpt":"","text":"C++第二章const 限定符变量 加上const会变成常量，不可更改值，相当于Java中的final&amp;引用在C++中引用属于复合类型1234int var=200; //定义一个变量int &amp;a=var; //引用类型a 记录var值int &amp;b;//引用必须初始化int &amp;c=200；//引用不能文字变量来初始化引用别名123456int year = 2017; //定义一个变量int &amp;a= year; //引用赋值int &amp;name =a, &amp;name2 =a; //定义两个引用别名 name ，name2int time= 10.20;int &amp;name= time; // × 错误， 引用赋值后不能再重新引用到别的对象上。typedef 类型别名12typedef int zhengxing; //别名 zhengxing 为 int类型zhengxing a=1; //类型别名 实际zhengxing 为int 类型goto 无条件跳转123456789int main()&#123; int a=1; cout &lt;&lt;\"a的值为：\"&lt;&lt; a &lt;&lt; endl; // 1 goto theare; cout &lt;&lt; \"a加1的值为：\"&lt;&lt; a+1 &lt;&lt; endl; thear: cout &lt;&lt; \"a加1的值为：\"&lt;&lt; a+2 &lt;&lt; endl; //直接跳到这里 输出 3 retuen 0;&#125;String 类123String a = \"a\";String b = \"b\";String c = \"c\"+\"d\";// × 不允许， 加号左右必须有一个类型为String类型才可以","categories":[],"tags":[]},{"title":"C++ 第一章","slug":"yuque/nk857b","date":"2019-03-18T09:15:22.000Z","updated":"2019-04-03T03:18:11.646Z","comments":true,"path":"2019/03/18/yuque/nk857b/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/nk857b/","excerpt":"","text":"C++ 基本知识C++编译过程源文件(.cpp)-&gt;目标文件(.obj)-&gt;可执行文件(*.exe)C++命名规则只能使用字母字符数字和下划线（_）第一个不能是数字C++是区分大小写的不能使用C++关键词命名空间using namespace 指明来自哪个空间头文件有两种使用方式123#include&lt;*&gt; //尖括号是标准头文件预先检查#include\".*\" //用户自己提供的头文件基本数据类型类型大小short int16int16long int32char8wchar_t16boolN/Afloat6double10long double10","categories":[],"tags":[]},{"title":"C++ 纯虚函数","slug":"yuque/wbqfdt","date":"2019-03-18T09:14:54.000Z","updated":"2019-04-03T03:18:11.647Z","comments":true,"path":"2019/03/18/yuque/wbqfdt/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/wbqfdt/","excerpt":"","text":"C++纯虚函数（抽象类）纯虚函数类似JAVA中的抽象类如果父类有纯虚函数，子类继承时，如果不去实现这个函数，则不能被实例化没有实现纯虚函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;/** * C++纯虚函数（抽象类） */using namespace std;class Shape &#123;public: Shape(); ~Shape(); virtual double calcArea(); virtual void test()=0;&#125;;class Circle : Shape &#123;public: Circle(int r); ~Circle();protected: int m_r;&#125;;Circle::Circle(int r) &#123; m_r = r;&#125;Circle::~Circle() &#123;&#125;Shape::Shape() &#123;&#125;Shape::~Shape() &#123;&#125;double Shape::calcArea() &#123;&#125;int main() &#123; //纯虚函数 Circle circle(2); //直接报错，无法编译， 没有实现纯虚函数 return 0;&#125;实现纯虚函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;/** * C++纯虚函数（抽象类） */using namespace std;class Shape &#123;public: Shape(); ~Shape(); virtual double calcArea(); virtual void test()=0;&#125;;class Circle : Shape &#123;public: Circle(int r); ~Circle(); virtual void test();protected: int m_r;&#125;;Circle::Circle(int r) &#123; m_r = r;&#125;Circle::~Circle() &#123;&#125;void Circle::test() &#123; cout &lt;&lt; \"test()\" &lt;&lt; endl;&#125;Shape::Shape() &#123;&#125;Shape::~Shape() &#123;&#125;double Shape::calcArea() &#123;&#125;int main() &#123; //纯虚函数 Circle circle(2); //实现纯虚函数后 编译执行通过 return 0;&#125;","categories":[],"tags":[]},{"title":"相机参数知识","slug":"yuque/zr6nul","date":"2019-03-18T09:12:44.000Z","updated":"2019-04-03T03:18:11.647Z","comments":true,"path":"2019/03/18/yuque/zr6nul/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/zr6nul/","excerpt":"","text":"大疆无人机会机载相机，所以需要学会一些相机的参数，便于快速开发调试无人机相机模式AF/自动对焦：自动对焦模式又分为三种（单次/连续/手动）单次对焦：只对焦一次连续对焦：会多次尝试对焦手动：就是手动MF/手动对焦曝光三大要素快门：控制拍照时间光圈：控制相机接收的光亮ISO：白平衡拍照模式P/程序自动挡：相机自动控制光圈快门，其他的设置需要手动，例如/IOS白平衡A/光圈优先挡：相机自动快门，光圈自己设置（光圈值越小，光圈越大，光圈越大，景深越好）快门时间越慢捕捉的光线就越多，如果发生抖动的话，照片会糊掉Auto：全自动M/手动：手动","categories":[],"tags":[]},{"title":"类对象定义 三","slug":"yuque/uov3uy","date":"2019-03-18T09:11:58.000Z","updated":"2019-04-03T03:18:11.649Z","comments":true,"path":"2019/03/18/yuque/uov3uy/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/uov3uy/","excerpt":"","text":"浅拷贝浅拷贝：拷贝后，两个对象会共同指向一个地址，如果有一个对象更改了数据，另一个对象也会受影响，删除对象话，可能会导致释放两次12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;//.hclass student &#123;public: student(); student(string name); student(const student &amp;stu); ~student(); string getName(); int age;private: string m_name;&#125;;//cpp 这叫定义student::student() &#123; m_name=\"kitty\"; m_p=new int[5]; cout&lt;&lt;\"gou zao\"&lt;&lt;endl;&#125;string student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;//拷贝构造函数 （浅拷贝）student::student(const student &amp;stu) &#123;// 如果通过 student stu1=stu 这样的方式创建度对象，会执行拷贝构造函数 m_name=stu.m_name; //浅拷贝 m_p=stu.m_p;//浅拷贝 将复制的对象的 指针拷贝给了 另一个对象， 现在两个对象 共同指向了一个 地址 cout&lt;&lt;\"qian kaobei\"&lt;&lt;endl;&#125;student::~student() &#123; delete []m_p; //这样删除的话，浅拷贝会出问题 cout&lt;&lt;\"xi gou\"&lt;&lt;endl;&#125;void student::printAddr() &#123; cout&lt;&lt;\"dizhi:\"&lt;&lt;*m_p&lt;&lt;endl;&#125;void test(student s)&#123;&#125;int main() &#123; student s; student s1(s); s.printAddr(); s1.printAddr(); return 0;&#125;深拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;//.hclass student &#123;public: student(); student(string name); student(const student &amp;stu); ~student(); string getName(); void printAddr();private: int count; string m_name; int *m_p;&#125;;//cpp 这叫定义student::student() &#123; m_name=\"kitty\"; count=5; m_p=new int[count]; //初始化数组 for (int i = 0; i &lt; 5; i++) &#123;//数组赋值 m_p[i]=i; cout&lt;&lt;\"value:\"&lt;&lt;m_p[i]&lt;&lt;endl; &#125; cout&lt;&lt;\"gou zao\"&lt;&lt;endl;&#125;string student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;//拷贝构造函数 （深拷贝）student::student(const student &amp;stu) &#123; count=stu.count; //深拷贝 重新开辟一块内存空间 m_p=new int [count]; for (int i = 0; i &lt;count; i++) &#123; m_p[i]=stu.m_p[i]; &#125; cout&lt;&lt;\"shen kaobei\"&lt;&lt;endl;&#125;student::~student() &#123; delete []m_p; cout&lt;&lt;\"xi gou\"&lt;&lt;endl;&#125;void student::printAddr() &#123; cout&lt;&lt;\"dizhi:\"&lt;&lt;m_p&lt;&lt;endl;&#125;void test(student s)&#123;&#125;int main() &#123; student s; student s1(s); s.printAddr(); s1.printAddr(); return 0;&#125;对象指针1234567int main() &#123; student *s=new student(); s-&gt;printAddr(); student *s1=new student(); (*s1).printAddr(); return 0;&#125;对象成员指针对象成员指针 类似JAVA中的 对象属性例如：private Bean bean;指针类型大小为：41234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;class Teacher &#123;public: Teacher(string name, int age); ~Teacher(); string getName(); int getAge();private: string m_Name; int m_Age;&#125;;//.hclass Student &#123;public: Student(string nameA, int ageA, string nameB , int ageB); ~Student(); void printInfo();private: Teacher *m_teacherA; Teacher *m_teacherB;&#125;;Teacher::Teacher(string name, int age) &#123; m_Name = name; m_Age = age; cout &lt;&lt; \"Teacher gou zao name: \" &lt;&lt; m_Name &lt;&lt; \" age: \" &lt;&lt; m_Age &lt;&lt; endl;&#125;Teacher::~Teacher() &#123; cout &lt;&lt; \"Teacher xi gou name: \" &lt;&lt; m_Name &lt;&lt; \" age: \" &lt;&lt; m_Age &lt;&lt; endl;&#125;int Teacher::getAge() &#123; return m_Age;&#125;string Teacher::getName() &#123; return m_Name;&#125;//cpp 这叫定义Student::Student(string nameA, int ageA, string nameB , int ageB) &#123; m_teacherA=new Teacher(nameA,ageA); m_teacherB=new Teacher(nameB,ageB); cout &lt;&lt; \"Student gou zao\" &lt;&lt; endl;&#125;Student::~Student() &#123; delete m_teacherA; delete m_teacherB; cout &lt;&lt; \"Student xi gou\" &lt;&lt; endl;&#125;void Student::printInfo() &#123; cout &lt;&lt; \"printInfo\" &lt;&lt; endl; cout &lt;&lt; \"( A: \" &lt;&lt;m_teacherA-&gt;getName()&lt;&lt;\",\"&lt;&lt;m_teacherA-&gt;getAge()&lt;&lt;\")\"&lt;&lt; endl; cout &lt;&lt; \"( B: \" &lt;&lt;m_teacherB-&gt;getName()&lt;&lt;\",\"&lt;&lt;m_teacherB-&gt;getAge()&lt;&lt;\")\"&lt;&lt; endl;&#125;int main() &#123; Student *s=new Student(\"kitty\",20,\"tony\",22); (*s).printInfo(); cout&lt;&lt; sizeof(s)&lt;&lt;endl; cout&lt;&lt; sizeof(Student)&lt;&lt;endl; delete s; return 0;&#125;123456789101112输出结果：Teacher gou zao name: kitty age: 20Teacher gou zao name: tony age: 22Student gou zaoprintInfo( A: kitty,20)( B: tony,22)48Teacher xi gou name: kitty age: 20Teacher xi gou name: tony age: 22Student xi gouthis 指针和JAVA中的this指针差不多一个意思","categories":[],"tags":[]},{"title":"类对象定义 二","slug":"yuque/yuai84","date":"2019-03-18T09:10:20.000Z","updated":"2019-04-03T03:18:11.650Z","comments":true,"path":"2019/03/18/yuque/yuai84/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/yuai84/","excerpt":"","text":"类对象定义C++类访问修饰符数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public、private、protected 来指定的。关键字 public、private、protected 称为访问修饰符。123456789101112131415class Base &#123; public: // 公有成员 protected: // 受保护成员 private: // 私有成员 &#125;;公共（public）成员公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std; class Line&#123; public: double length; void setLength( double len ); double getLength( void );&#125;; // 成员函数定义double Line::getLength(void)&#123; return length ;&#125; void Line::setLength( double len )&#123; length = len;&#125; // 程序的主函数int main( )&#123; Line line; // 设置长度 line.setLength(6.0); cout &lt;&lt; \"Length of line : \" &lt;&lt; line.getLength() &lt;&lt;endl; // 不使用成员函数设置长度 line.length = 10.0; // OK: 因为 length 是公有的 cout &lt;&lt; \"Length of line : \" &lt;&lt; line.length &lt;&lt;endl; return 0;&#125;私有（private）成员私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt; using namespace std; class Box&#123; //double width; 不填写权限，默认是私有权限修饰符 public: double length; void setWidth( double wid ); double getWidth( void ); private: double width;&#125;; // 成员函数定义double Box::getWidth(void)&#123; return width ;&#125; void Box::setWidth( double wid )&#123; width = wid;&#125; // 程序的主函数int main( )&#123; Box box; // 不使用成员函数设置长度 box.length = 10.0; // OK: 因为 length 是公有的 cout &lt;&lt; \"Length of box : \" &lt;&lt; box.length &lt;&lt;endl; // 不使用成员函数设置宽度 // box.width = 10.0; // Error: 因为 width 是私有的 box.setWidth(10.0); // 使用成员函数设置宽度 cout &lt;&lt; \"Width of box : \" &lt;&lt; box.getWidth() &lt;&lt;endl; return 0;&#125;保护（protected）成员保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std; class Box&#123; protected: double width;&#125;; class SmallBox:Box // SmallBox 是子类（继承关系）&#123; public: void setSmallWidth( double wid ); double getSmallWidth( void );&#125;; // 子类的成员函数double SmallBox::getSmallWidth(void)&#123; return width ;&#125; void SmallBox::setSmallWidth( double wid )&#123; width = wid;&#125; // 程序的主函数int main( )&#123; SmallBox box; // 使用成员函数设置宽度 box.setSmallWidth(5.0); cout &lt;&lt; \"Width of box : \"&lt;&lt; box.getSmallWidth() &lt;&lt; endl; return 0;&#125;继承中的特点有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private但无论哪种继承方式，上面两点都没有改变：1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；2.protected 成员可以被派生类访问。public 继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std; class A&#123;public: int a; A()&#123; a1 = 1; a2 = 2; a3 = 3; a = 4; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确 cout &lt;&lt; a3 &lt;&lt; endl; //正确 &#125;public: int a1;protected: int a2;private: int a3;&#125;;class B : public A&#123;public: int a; B(int i)&#123; A(); a = i; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确，public成员 cout &lt;&lt; a1 &lt;&lt; endl; //正确，基类的public成员，在派生类中仍是public成员。 cout &lt;&lt; a2 &lt;&lt; endl; //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。 cout &lt;&lt; a3 &lt;&lt; endl; //错误，基类的private成员不能被派生类访问。 &#125;&#125;;int main()&#123; B b(10); cout &lt;&lt; b.a &lt;&lt; endl; cout &lt;&lt; b.a1 &lt;&lt; endl; //正确 cout &lt;&lt; b.a2 &lt;&lt; endl; //错误，类外不能访问protected成员 cout &lt;&lt; b.a3 &lt;&lt; endl; //错误，类外不能访问private成员 system(\"pause\"); return 0;&#125;protected 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;class A&#123;public: int a; A()&#123; a1 = 1; a2 = 2; a3 = 3; a = 4; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确 cout &lt;&lt; a3 &lt;&lt; endl; //正确 &#125;public: int a1;protected: int a2;private: int a3;&#125;;class B : protected A&#123;public: int a; B(int i)&#123; A(); a = i; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确，public成员。 cout &lt;&lt; a1 &lt;&lt; endl; //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。 cout &lt;&lt; a2 &lt;&lt; endl; //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。 cout &lt;&lt; a3 &lt;&lt; endl; //错误，基类的private成员不能被派生类访问。 &#125;&#125;;int main()&#123; B b(10); cout &lt;&lt; b.a &lt;&lt; endl; //正确。public成员 cout &lt;&lt; b.a1 &lt;&lt; endl; //错误，protected成员不能在类外访问。 cout &lt;&lt; b.a2 &lt;&lt; endl; //错误，protected成员不能在类外访问。 cout &lt;&lt; b.a3 &lt;&lt; endl; //错误，private成员不能在类外访问。 system(\"pause\"); return 0;&#125;private 继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;assert.h&gt;using namespace std;class A&#123;public: int a; A()&#123; a1 = 1; a2 = 2; a3 = 3; a = 4; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确 cout &lt;&lt; a1 &lt;&lt; endl; //正确 cout &lt;&lt; a2 &lt;&lt; endl; //正确 cout &lt;&lt; a3 &lt;&lt; endl; //正确 &#125;public: int a1;protected: int a2;private: int a3;&#125;;class B : private A&#123;public: int a; B(int i)&#123; A(); a = i; &#125; void fun()&#123; cout &lt;&lt; a &lt;&lt; endl; //正确，public成员。 cout &lt;&lt; a1 &lt;&lt; endl; //正确，基类public成员,在派生类中变成了private,可以被派生类访问。 cout &lt;&lt; a2 &lt;&lt; endl; //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。 cout &lt;&lt; a3 &lt;&lt; endl; //错误，基类的private成员不能被派生类访问。 &#125;&#125;;int main()&#123; B b(10); cout &lt;&lt; b.a &lt;&lt; endl; //正确。public成员 cout &lt;&lt; b.a1 &lt;&lt; endl; //错误，private成员不能在类外访问。 cout &lt;&lt; b.a2 &lt;&lt; endl; //错误, private成员不能在类外访问。 cout &lt;&lt; b.a3 &lt;&lt; endl; //错误，private成员不能在类外访问。 system(\"pause\"); return 0;&#125;","categories":[],"tags":[]},{"title":"类对象定义 一","slug":"yuque/zqi5k0","date":"2019-03-18T09:09:03.000Z","updated":"2019-04-03T03:18:11.651Z","comments":true,"path":"2019/03/18/yuque/zqi5k0/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/zqi5k0/","excerpt":"","text":"指针类型通过-&gt;来访问属性类对象通过.来访问属性类外定义.h 定义声明类12345678910111213141516171819202122232425#ifndef CPPDEMO_DUIXIANG_H#define CPPDEMO_DUIXIANG_H#include &lt;string&gt;using namespace std;/** 类头文件*/class demo &#123;public: void setAge(int _age); int getAge(); void setName(string _name); string getName();private: string name; int age;&#125;;#endif //CPPDEMO_DUIXIANG_Hcpp实现定义头文件12345678910111213#include \"demo.h\"void demo::setAge(int _age) &#123; age=_age;&#125;void demo::setName(string _name) &#123; name=_name;&#125;int demo::getAge() &#123; return age;&#125;string demo::getName() &#123; return name;&#125;使用对象1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;#include \"demo.h\"using namespace std;int main() &#123; demo m; m.setAge(12); m.setName(\"guolei\"); cout&lt;&lt;\"年龄:\"&lt;&lt;m.getAge()&lt;&lt;\" 名字: \"&lt;&lt;m.getName()&lt;&lt;endl; return 0;&#125;构造函数12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class student &#123;public: student(); student(string name); string getName();private: string m_name;&#125;;string student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;student::student() &#123; cout &lt;&lt; \"无参构造函数\" &lt;&lt; endl;&#125;int main() &#123; student *s= new student();//无参构造函数 student *s2=new student(\"kitty2\");//有参构造函数 std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s-&gt;getName() &lt;&lt;std::endl; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s2-&gt;getName() &lt;&lt;std::endl; return 0;&#125;构造函数初始化列表const 类型 只能通过 初始化列表来 初始化数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;class student &#123;public:/** student::student( string name): m_name(name) &#123; cout &lt;&lt; \"初始化列表 \" &lt;&lt; endl; &#125; 上面的语法等同于如下语法： student::student( string name) &#123; m_name = name; &#125; 假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的 字段使用逗号进行分隔，如下所示： C::C( double a, double b, double c): X(a), Y(b), Z(c) &#123; .... &#125; */ student():m_name(\"kittyg\"),age(20)&#123;&#125; //初始化列表 初始化字段 student(string name);//带参构造函数 string getName(); int getAge();private: string m_name; int age;&#125;;int main() &#123; student *s= new student(); student *s2=new student(\"kitty2\"); std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s-&gt;getName() &lt;&lt;\" age:\"&lt;&lt;s-&gt;getAge()&lt;&lt;std::endl; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s2-&gt;getName() &lt;&lt;std::endl; return 0;&#125;string student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;int student::getAge() &#123; return age;&#125;拷贝构造函数定义格式： 类名（const类名&amp;变量名）如果没有自定义拷贝构造函数则自动生成一个默认的拷贝构造函数当采用直接初始化或复制初始化实例化对象时，自动调用拷贝构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;//.hclass student &#123;public: student():m_name(\"kittyg\"),age(20)&#123;&#125;//列表初始化字段 student(string name); student(const student &amp;stu);//拷贝构造函数 string getName(); int getAge();private: string m_name; int age;&#125;;//cppstring student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;int student::getAge() &#123; return age;&#125;student::student(const student &amp;stu) &#123; //实现拷贝构造函数 cout&lt;&lt;\"keo bei\"&lt;&lt;endl;&#125;//测试函数void test(student s)&#123;&#125;int main() &#123; student s; student *s2=new student(\"kitty2\"); student s3=s; test(s3); //函数传递对象的时候 也会触发 拷贝构造函数 std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s.getName() &lt;&lt;\" age:\"&lt;&lt;s.getAge()&lt;&lt;std::endl; std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s2-&gt;getName() &lt;&lt;std::endl; return 0;&#125;析构函数主要用于善后处理，一般用于释放内存如果没有自定义析构函数则自动生成析构函数在对象销毁时自动调用析构函数没有返回值，没有参数也不能重载对象的生命历程申请内存-&gt;初始化列表-&gt;构造函数-&gt;参与运算或执行逻辑-&gt;析构函数-&gt;释放内存12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;//.hclass student &#123;public: student(); student(string name); student(const student &amp;stu);//拷贝构造函数 ~student();//析构构造函数 string getName();private: string m_name;&#125;;//cppstudent::student() &#123;&#125;string student::getName()&#123; return m_name;&#125;student::student(string name) &#123; m_name=name;&#125;student::student(const student &amp;stu) &#123; cout&lt;&lt;\"keo bei\"&lt;&lt;endl;&#125;student::~student() &#123; cout&lt;&lt;\"xi gou\"&lt;&lt;endl;&#125;void test(student s)&#123;&#125;int main() &#123; student s; student *s2=new student(\"kitty2\"); std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; \"name:\"&lt;&lt; s2-&gt;getName() &lt;&lt;std::endl; delete s2;// 触发析构函数 return 0;&#125;","categories":[],"tags":[]},{"title":"WEB前端 HTML标签","slug":"yuque/xqfp88","date":"2019-03-18T09:07:28.000Z","updated":"2019-04-03T03:18:11.651Z","comments":true,"path":"2019/03/18/yuque/xqfp88/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/xqfp88/","excerpt":"","text":"HTML标签123456789101112131415标题标签:&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt; 注： h1 标签因为重要，尽量少用, 一般h1 都是给logo使用。段落标签: &lt;p&gt;水平线标签: &lt;hr /&gt; 注:是单标签换行标签: &lt;br /&gt;盒子标签： div span div ：分区 span：度，跨距文本格式化标签： &lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt; 文本加粗 &lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt; 文本倾斜&lt;s&gt;&lt;/s&gt;&lt;del&gt;&lt;/del&gt; 文本删除线&lt;u&gt;&lt;/u&gt;&lt;ins&gt;&lt;/ins&gt; 文本下划线标签属性1&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …&gt; 内容 &lt;/标签名&gt;标签属性场景123456&lt;!---水平线---&gt;&lt;hr width=\"400\" /&gt;&lt;!---图像---&gt;&lt;img src=\"图像URL\" /&gt;&lt;!---链接---&gt;&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt;列表标签12345678910111213141516171819202122232425262728&lt;!--- 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。----&gt;&lt;!---无序列表---&gt;&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt;&lt;!---有序列表---&gt;&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt;&lt;!---自定义列表---&gt;&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ...&lt;/dl&gt;表格标签12345678910111213141516171819202122232425262728&lt;table width=\"500\" height=\"300\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\"&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td rowspan=\"3\"&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李磊&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;kitty&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"3\"&gt;胖虎&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;表单标签12345678910111213141516171819&lt;form action=\"xxx.php\" method=\"get\" name=\"userMessage\"&gt; 用户名: &lt;input type=\"text\" value=\"提示\"/&gt; &lt;!-- 这是一个文本框 --&gt; &lt;br/&gt; 密 码: &lt;input type=\"password\" maxlength=\"6\"/&gt; &lt;br/&gt; 性 别: &lt;input type=\"radio\" name=\"sex\"/&gt; 女 &lt;input type=\"radio\" name=\"sex\" checked=\"checked\"/&gt; 男 &lt;br/&gt; &lt;!-- 单选框 如果是一组，我们通过相同的name值 来实现--&gt; 爱 好: &lt;input type=\"checkbox\" name=\"hobby\" checked=\"checked\"/&gt; 足球 &lt;input type=\"checkbox\" name=\"hobby\"/&gt; 篮球 &lt;!-- 复选框 可以同时选择多个 --&gt;&lt;br/&gt; 按钮： &lt;input type=\"button\" value=\"按钮\"/&gt; &lt;!-- 普通按钮 --&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交表单\"/&gt;&lt;!-- 提交按钮 --&gt; &lt;input type=\"reset\" value=\"重置表单\"/&gt;&lt;!-- 重置按钮 --&gt;&lt;br/&gt; &lt;input type=\"image\" src=\"im.jpg\"/&gt;&lt;!-- 图像按钮 --&gt;&lt;br/&gt; 上传头像: &lt;input type=\"file\"/&gt; &lt;!-- 文件按钮 --&gt;&lt;/form&gt;","categories":[],"tags":[]},{"title":"WEB前端初识","slug":"yuque/vvkxes","date":"2019-03-18T09:01:15.000Z","updated":"2019-04-03T03:18:11.653Z","comments":true,"path":"2019/03/18/yuque/vvkxes/","link":"","permalink":"www.kitty.kim/2019/03/18/yuque/vvkxes/","excerpt":"","text":"—title: 标签测试文章tags: [Hexo]categories: Web前端description: web前端初识浏览器1浏览器是网页运行的平台，常用的五大浏览器：IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera什么是浏览器内核12345678910内核分为两部分：渲染引擎 和 JS 引擎。 渲染引擎（layout engineer 或者 Rendering Engine）：负责渲染网页，通过HTML、XML，CSS等，计算网页显示的方式，然后输出至显示器或打印机。（浏览器内核的不同，对应网页的语法解释会有不同，渲染效果也会不同）JS引擎： 则是解析Javascript 语言，执行 javascript语言来实现网页的动态效果。注：最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎，但是常见的浏览器内核可以分这四种：Trident（IE）、Gecko（firefox）、Blink（chrome）、Webkit（Safari）。移动端浏览器内核： iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。WEB标准的好处1234567891011让Web的发展前景更广阔 内容能被更广泛的设备访问更容易被搜寻引擎搜索降低网站流量费用使网站更易于维护提高页面浏览速度Web 标准构成主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分HTML初识1HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。1234567891011&lt;!--最简单的HTML网页--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这里是文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;HTML标签分类1.双标签1&lt;标签名&gt; 内容 &lt;/标签名&gt;2.单标签1&lt;标签名 /&gt;单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt;字符集1&lt;meta charset=\"UTF-8\"&gt;utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。gb2312 简单中文 包括6763个汉字BIG5 繁体中文 港澳台等用GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312UTF-8则包含全世界所有国家需要用到的字符浏览器1浏览器是网页运行的平台，常用的五大浏览器：IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera什么是浏览器内核123456789内核分为两部分：渲染引擎 和 JS 引擎。渲染引擎（layout engineer 或者 Rendering Engine）：负责渲染网页，通过HTML、XML，CSS等，计算网页显示的方式，然后输出至显示器或打印机。（浏览器内核的不同，对应网页的语法解释会有不同，渲染效果也会不同）JS引擎 : 则是解析Javascript 语言，执行 javascript语言来实现网页的动态效果。注：最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎，但是常见的浏览器内核可以分这四种：Trident（IE）、Gecko（firefox）、Blink（chrome）、Webkit（Safari）。移动端浏览器内核： iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。WEB标准的好处1234567891011让Web的发展前景更广阔 内容能被更广泛的设备访问更容易被搜寻引擎搜索降低网站流量费用使网站更易于维护提高页面浏览速度Web 标准构成主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分HTML初识1HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。1234567891011&lt;!--最简单的HTML网页--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;这里是文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;HTML标签分类1.双标签1&lt;标签名&gt; 内容 &lt;/标签名&gt;2.单标签1&lt;标签名 /&gt;单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt;字符集1&lt;meta charset=\"UTF-8\"&gt;utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。gb2312 简单中文 包括6763个汉字BIG5 繁体中文 港澳台等用GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312UTF-8则包含全世界所有国家需要用到的字符","categories":[],"tags":[]},{"title":"Web","slug":"yuque/erfi70","date":"2019-03-03T16:42:03.000Z","updated":"2019-04-03T03:18:11.654Z","comments":true,"path":"2019/03/04/yuque/erfi70/","link":"","permalink":"www.kitty.kim/2019/03/04/yuque/erfi70/","excerpt":"","text":"这是一个测试页面,来着语雀！","categories":[],"tags":[]}]}