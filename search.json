[{"title":"Android DJI Mobile-SDK 开发","url":"/2019/03/20/yuque/plnquw/","content":"由于大疆的文档是英文的，看着不太舒服，虽然靠翻译插件进行翻译可也能看，但是来回的切换看比较麻烦，就搞一个中文的教程，基于SDK Version: 3.5.1（书到用时方恨少，后悔当年没好好学习英语）\n\n<a name=\"23ff0dd5\"></a>\n# 开发准备\n\n* **先去[开发者中心](https://developer.dji.com)注册账号**\n* **登录个人中心**\n\n![](https://cdn.nlark.com/yuque/0/2019/png/259158/1553065166533-5dc46782-00b0-4d23-ba56-fe1e90273b66.png#align=left&display=inline&height=332&originHeight=580&originWidth=1302&size=0&status=done&width=746)\n\n* **创建应用**\n\n![](https://cdn.nlark.com/yuque/0/2019/png/259158/1553065166687-62aa2522-f9bc-445f-a958-af9181208760.png#align=left&display=inline&height=559&originHeight=559&originWidth=601&size=0&status=done&width=601)\n\n---\n\n<a name=\"3ff3c3e2\"></a>\n## 开发\n\n> 可以参考大疆的Android文档    —— [ [ DJI ]](https://developer.dji.com/cn/mobile-sdk/documentation/android-tutorials/)\n\n\n* **下载Demo，将Demo 中的lib项目导入自己的项目工程中**\n* 配置AndroidManifest.xml\n\n**添加SDK所需要的权限**\n\n```xml\n<!-- SDK 需要的权限 -->\n    <uses-permission android:name=\"android.permission.BLUETOOTH\" />\n    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" />\n    <uses-permission android:name=\"android.permission.VIBRATE\" />\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\n    <uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <uses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\" />\n    \n\t<uses-feature android:name=\"android.hardware.camera\" />\n    <uses-feature android:name=\"android.hardware.camera.autofocus\" />\n    <uses-feature android:name=\"android.hardware.usb.host\" android:required=\"false\" />\n    <uses-feature android:name=\"android.hardware.usb.accessory\" android:required=\"true\" />\n```\n\n**配置key以及服务**\n\n```xml\n<application\n        android:name=\".MyApplication\"\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/AppTheme\">\n\n        <meta-data\n            android:name=\"com.dji.sdk.API_KEY\"\n            android:value=\"自己应用申请的key\" />\n            \n\t<!-- 以下是官方dmeo默认的配置 -->\n        <service android:name=\"dji.sdk.sdkmanager.DJIGlobalService\" />\n\n        <service android:name=\"dji.internal.geofeature.flyforbid.FlyforbidUpdateService\" />\n\n        <!-- Required for receiving GEO system pushing. -->\n        <service android:name=\"dji.sdk.sdkmanager.GeoSyncFileService\"/>\n\n        <activity\n            android:name=\"dji.sdk.sdkmanager.DJIAoaControllerActivity\"\n            android:theme=\"@android:style/Theme.Translucent\" >\n            <intent-filter>\n                <action android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\" />\n            </intent-filter>\n\n            <meta-data\n                android:name=\"android.hardware.usb.action.USB_ACCESSORY_ATTACHED\"\n                android:resource=\"@xml/accessory_filter\" />\n        </activity>\n        \n\t <!-- 以上是官方dmeo默认的配置 -->\n \n        <activity android:name=\".MainActivity\"\n            android:screenOrientation=\"portrait\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        \n    </application>\n```\n\n<a name=\"MyApplication\"></a>\n## MyApplication\n\n> 用来初始化DJI SDK的一个类，写好后，别忘了配置到AndroidManifest.xml中\n\n\n```java\nimport android.app.Application;\nimport android.content.Intent;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.support.multidex.MultiDex;\nimport android.util.Log;\nimport android.widget.Toast;\nimport dji.common.error.DJIError;\nimport dji.common.error.DJISDKError;\nimport dji.sdk.base.DJIBaseComponent;\nimport dji.sdk.base.DJIBaseProduct;\nimport dji.sdk.products.DJIAircraft;\nimport dji.sdk.sdkmanager.DJISDKManager;\n\n\n/**\n * Created by kitty \n * Application  类用来初始化SDK\n */\n\npublic class MyApplication extends Application {\n    private static DJIBaseProduct mProduct;\n    private Handler mHandler;\n    public static final String FLAG_CONNECTION_CHANGE =\"com_example_dji_sdkdemo3_connection_change\";\n\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        //初始化SDK\n        DJISDKManager.getInstance().initSDKManager(this, mDJISDKManagerCallback);\n    }\n\n    /**\n     * 注册监听\n     */\n   private DJISDKManager.DJISDKManagerCallback mDJISDKManagerCallback = new DJISDKManager.DJISDKManagerCallback() {\n        //判断是否注册成功回调\n        @Override\n        public void onGetRegisteredResult(DJIError error) {\n\n            if (error == DJISDKError.REGISTRATION_SUCCESS) {\n\n                Handler handler = new Handler(Looper.getMainLooper());\n                handler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(getApplicationContext(), \"注册成功\", Toast.LENGTH_LONG).show();\n                    }\n                });\n                DJISDKManager.getInstance().startConnectionToProduct();\n            } else {\n\n                Handler handler = new Handler(Looper.getMainLooper());\n                handler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(getApplicationContext(), \"注册失败，或者网络问题\", Toast.LENGTH_LONG).show();\n                    }\n                });\n            }\n            Log.e(\"TAG\", error.toString());\n        }\n\n        //监听状态\n        @Override\n        public void onProductChanged(DJIBaseProduct oldProduct, DJIBaseProduct newProduct) {\n            mProduct = newProduct;\n            if (mProduct != null) {\n                mProduct.setDJIBaseProductListener(mDJIBaseProductListener);\n            }\n            notifyStatusChange();\n        }\n    };\n    private DJIBaseProduct.DJIBaseProductListener mDJIBaseProductListener = new DJIBaseProduct.DJIBaseProductListener() {\n        @Override\n        public void onComponentChange(DJIBaseProduct.DJIComponentKey key, DJIBaseComponent oldComponent, DJIBaseComponent newComponent) {\n            if (newComponent != null) {\n                newComponent.setDJIComponentListener(mDJIComponentListener);\n            }\n            notifyStatusChange();\n        }\n\n        @Override\n        public void onProductConnectivityChanged(boolean isConnected) {\n            notifyStatusChange();\n        }\n    };\n    private DJIBaseComponent.DJIComponentListener mDJIComponentListener = new DJIBaseComponent.DJIComponentListener() {\n\n        @Override\n        public void onComponentConnectivityChanged(boolean isConnected) {\n            Log.d(\"Alex\", \"onComponentConnectivityChanged: \" + isConnected);\n            notifyStatusChange();\n        }\n\n    };\n\n    private void notifyStatusChange() {\n        mHandler.removeCallbacks(updateRunnable);\n        mHandler.postDelayed(updateRunnable, 500);\n    }\n\n    private Runnable updateRunnable = new Runnable() {\n\n        @Override\n        public void run() {\n            Intent intent = new Intent(FLAG_CONNECTION_CHANGE);\n            sendBroadcast(intent);\n        }\n    };\n\n    /**\n     * 获得指定的实例\n     */\n    public static synchronized DJIBaseProduct getProductInstance() {\n        if (null == mProduct) {\n            mProduct = DJISDKManager.getInstance().getDJIProduct();\n        }\n        return mProduct;\n    }\n}\n```\n\n---\n\n<a name=\"MainActivity\"></a>\n### MainActivity\n\n* **界面**\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n    \n    <TextView\n        android:id=\"@+id/text_connection_status\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:gravity=\"center\"\n        android:text=\"Status: No Product Connected\"\n        android:textColor=\"@android:color/black\"\n        android:textSize=\"20dp\"\n        android:textStyle=\"bold\"\n        android:layout_alignBottom=\"@+id/text_product_info\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginBottom=\"89dp\" />\n        \n    <TextView\n        android:id=\"@+id/text_product_info\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"150dp\"\n        android:text=\"product_information\"\n        android:textColor=\"@android:color/black\"\n        android:textSize=\"20dp\"\n        android:gravity=\"center\"\n        android:textStyle=\"bold\"\n        />\n   \n    <Button\n        android:id=\"@+id/btn_open\"\n        android:layout_width=\"150dp\"\n        android:layout_height=\"55dp\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"250dp\"\n        android:background=\"@drawable/round_btn\"\n        android:text=\"Open\"\n        android:textColor=\"@android:color/white\"\n        android:textSize=\"20dp\"\n        />\n\n   \n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:textAppearance=\"?android:attr/textAppearanceSmall\"\n        android:text=\"Demo\"\n        android:id=\"@+id/textView\"\n        android:layout_marginTop=\"30dp\"\n        android:textStyle=\"bold\"\n        android:textSize=\"20dp\"\n        android:textColor=\"@color/colorAccent\"\n        android:layout_alignParentTop=\"true\"\n        android:layout_centerHorizontal=\"true\" />\n        \n</RelativeLayout>\n```\n\n* **Code**\n\n```java\nimport android.Manifest;\nimport android.app.Activity;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.v4.app.ActivityCompat;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport dji.sdk.base.DJIBaseProduct;\nimport dji.sdk.products.DJIAircraft;\n\n/**\n * Created by kitty on 2017/3/1.\n * 连接页面\n */\n\npublic class MainActivityextends Activity implements View.OnClickListener, DJIBaseProduct.DJIVersionCallback {\n\n    private static final String TAG = MainActivity.class.getName();\n    private TextView mTextConnectionStatus;\n    private TextView mTextProduct;\n    private Button mBtnOpen;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //判断版本，进行动态获取权限\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            ActivityCompat.requestPermissions(this,\n                    new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.VIBRATE,\n                            Manifest.permission.INTERNET, Manifest.permission.ACCESS_WIFI_STATE,\n                            Manifest.permission.WAKE_LOCK, Manifest.permission.ACCESS_COARSE_LOCATION,\n                            Manifest.permission.ACCESS_NETWORK_STATE, Manifest.permission.ACCESS_FINE_LOCATION,\n                            Manifest.permission.CHANGE_WIFI_STATE, Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS,\n                            Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.SYSTEM_ALERT_WINDOW,\n                            Manifest.permission.READ_PHONE_STATE,\n                    }\n                    , 1);\n        }\n        setContentView(R.layout.activity_main);\n        initUI();\n        //注册广播，连接成功 更新UI用\n        IntentFilter filter = new IntentFilter();\n        filter.addAction(MainActivity.FLAG_CONNECTION_CHANGE);\n        registerReceiver(mReceiver, filter);\n    }\n\n\n    private void initUI() {\n        mTextConnectionStatus = (TextView) findViewById(R.id.text_connection_status);\n        mTextProduct = (TextView) findViewById(R.id.text_product_info);\n        //open按钮\n        mBtnOpen = (Button) findViewById(R.id.btn_open);\n        mBtnOpen.setOnClickListener(this);\n        mBtnOpen.setEnabled(false);\n    }\n\t//连接成功广播更新UI\n    protected BroadcastReceiver mReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            refreshSDKRelativeUI();\n        }\n    };\n\t//更新UI\n    private void refreshSDKRelativeUI() {\n        DJIBaseProduct mProduct = MainActivity.getProductInstance();\n        if (null != mProduct && mProduct.isConnected()) {\n            mBtnOpen.setEnabled(true);\n            String str = mProduct instanceof DJIAircraft ? \"DJIAircraft\" : \"DJIHandHeld\";\n            mTextConnectionStatus.setText(\"Status: \" + str + \" connected\");\n            mProduct.setDJIVersionCallback(this);\n            if (null != mProduct.getModel()) {\n                mTextProduct.setText(\"\" + mProduct.getModel().getDisplayName());\n            } else {\n                mTextProduct.setText(R.string.product_information);\n            }\n        } else {\n            mBtnOpen.setEnabled(false);\n            mTextProduct.setText(R.string.product_information);\n            mTextConnectionStatus.setText(R.string.connection_loose);\n        }\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n        \n            case R.id.btn_open:\n                Intent intent = new Intent(this, OpenActivity.class);\n                startActivity(intent);\n                break;\n                \n            default:\n                break;\n        }\n    }\n\n    @Override\n    public void onProductVersionChange(String s, String s1) {\n        Log.e(\"ceshi\", \"ConnectionActivity.java-->onProductVersionChange()\");\n    }\n\n    @Override\n    public void onResume() {\n        Log.e(TAG, \"onResume\");\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        Log.e(TAG, \"onPause\");\n        super.onPause();\n    }\n\n    @Override\n    public void onStop() {\n        Log.e(TAG, \"onStop\");\n        super.onStop();\n    }\n\n    public void onReturn(View view) {\n        Log.e(TAG, \"onReturn\");\n        this.finish();\n    }\n\n    @Override\n    protected void onDestroy() {\n        Log.e(TAG, \"onDestroy\");\n        unregisterReceiver(mReceiver);\n        super.onDestroy();\n    }\n}\n```\n\n<a name=\"OpenActivity\"></a>\n## OpenActivity\n\n* **界面**\n\n```xml\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n    <TextureView\n        android:id=\"@+id/video_previewer_surface\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:layout_gravity=\"center\"\n        android:layout_centerHorizontal=\"true\" />\n\n    \n</RelativeLayout>\n```\n\n* **Code**\n\n```java\n/**\n * 连接成功显示页面\n */\npublic class OpenActivity extends AppCompatActivity implements  TextureView.SurfaceTextureListener {\n\n    protected TextureView mVideoSurface = null;\n    private static final String TAG = OpenActivity.class.getName();\n    protected DJICamera.CameraReceivedVideoDataCallback mReceivedVideoDataCallBack = null;\n    DJICodecManager mCodecManager;\n    private DJICamera camera;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n \n        setContentView(R.layout. open);\n        //初始化界面 \n        initUI();\n        //显示回调\n        mReceivedVideoDataCallBack = new DJICamera.CameraReceivedVideoDataCallback() {\n            @Override\n            public void onResult(byte[] videoBuffer, int size) {\n\n                if (mCodecManager != null) {\n                    // Send the raw H264 video data to codec manager for decoding\n                    mCodecManager.sendDataToDecoder(videoBuffer, size);\n                } else {\n                    Log.e(TAG, \"mCodecManager is null\");\n                }\n            }\n        };\n    }\n\n    protected void onProductChange() {\n        initPreviewer();\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n        \n        initPreviewer();\n        \n        onProductChange();\n        if (mVideoSurface == null) {\n            Log.e(\"ceshi\", \"mVideoSurface 显示界面为空\");\n        }\n\n    }\n\n    private void initPreviewer() {\n        DJIBaseProduct product = MyApplication.getProductInstance();\n        if (product == null || !product.isConnected()) {\n//            showToast(getString(R.string.disconnected));\n            Toast.makeText(getApplicationContext(), \"无连接\", Toast.LENGTH_SHORT).show();\n        } else {\n            Toast.makeText(getApplicationContext(), \"以连接\", Toast.LENGTH_LONG).show();\n            if (null != mVideoSurface) {\n                mVideoSurface.setSurfaceTextureListener(this);\n            }\n            if (!product.getModel().equals(product.getModel().UnknownAircraft)) {\n                DJICamera camera = product.getCamera();\n                if (camera != null) {\n                    // Set the callback\n                    camera.setDJICameraReceivedVideoDataCallback(mReceivedVideoDataCallBack);\n                }\n            }\n        }\n    }\n\n    private void uninitPreviewer() {\n        DJICamera camera = MyApplication.getProductInstance().getCamera();\n        if (camera != null) {\n            // Reset the callback\n        MyApplication.getProductInstance().getCamera().setDJICameraReceivedVideoDataCallback(null);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n    @Override\n    public void onStop() {\n        uninitPreviewer();\n        super.onStop();\n    }\n\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        uninitPreviewer();\n    }\n\n    @Override\n    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {\n        Log.e(TAG, \"onSurfaceTextureAvailable\");\n        if (mCodecManager == null) {\n            mCodecManager = new DJICodecManager(this, surface, width, height);\n        }\n    }\n\n    @Override\n    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {\n        Log.e(TAG, \"onSurfaceTextureSizeChanged\");\n    }\n\n    @Override\n    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {\n        Log.e(TAG, \"onSurfaceTextureDestroyed\");\n        if (mCodecManager != null) {\n            mCodecManager.cleanSurface();\n            mCodecManager = null;\n        }\n        return false;\n    }\n\n    @Override\n    public void onSurfaceTextureUpdated(SurfaceTexture surface) {\n    }\n\n    private void initUI() {\n        // 准备界面\n        mVideoSurface = (TextureView) findViewById(R.id.video_previewer_surface);\n        \n        if (null != mVideoSurface) {\n            mVideoSurface.setSurfaceTextureListener(this);\n        }\n\n    }\n}\n```\n\n<a name=\"ca944946\"></a>\n## 测试步骤\n\n* **手机连接遥控器**\n* **选择dmeo打开**\n* **连接飞机成功，点击open按钮，成功的话会显示画面**\n\n\n"},{"title":"C++ 虚析构和虚函数的原理","url":"/2019/03/18/yuque/cvfg0g/","content":"\n> C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议\n\n\n> 同名函数下，有virtual修饰=覆盖，无virtual=隐藏\n\n\n```\n1、类内没有数据成员的情况下，实例化对象所占字节为1字节，有数据成员为数据成员的大小之和；\n2、类内有虚成员函数，那么在实例化的时候会产生一个虚函数表指针，对象的大小为4字节。\n3、虚析构函数可以使类实例对象的时候一样为产生一个虚函数表指针，大小为4字节；\n```\n\n> 如果父类成员函数被virtual修饰，子类继承，会继承父类的虚函数表，如果子类同名的函数也被virtual修饰。\n\n\n> 也可以把父类的虚函数表的同名函数指针地址覆盖掉，变为自己的指针地址。\n\n\n例如：\n\n```cpp\n#include <iostream>\n/**\n * C++虚构函数和虚函数指针的原理\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    double calcArea();\n};\n\nclass Circle : Shape {\npublic:\n    Circle(int r);\n\n    ~Circle();\n\nprotected:\n    int m_r;\n};\n\nCircle::Circle(int r) {\n    m_r = r;\n}\n\nCircle::~Circle() {\n\n}\n\nShape::Shape() {\n\n}\n\nShape::~Shape() {\n\n}\n\ndouble Shape::calcArea() {\n\n}\n\nint main() {\n    Shape shape;\n    cout << sizeof(shape) << endl;\n    Circle circle(100);\n    cout << sizeof(circle) << endl; //一个int占4位\n    //计算机位数不同，位数显示的不一样\n    //64位计算机显示指针占8位\n    return 0;\n}\n```\n\n输出结果：\n\n```\n1  //如果对象 没有任何数据，1代表一个占位符，代表是一个对象\n4  //对象有成员数据的话，就显示成员数据占据的大小。\n```\n\n<a name=\"1db8e775\"></a>\n## 被virtual修饰后\n\n```cpp\n#include <iostream>\n/**\n * C++虚构函数和虚函数指针的原理\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    virtual double calcArea(); //被virtual修饰后 包含一个虚函数表 虚函数表也是一个指针类型 4位\n};\n\nint main() {\n     \n    Shape shape;\n    cout << sizeof(shape) << endl;\n    Circle circle(100);\n    cout << sizeof(circle) << endl;\n    return 0;\n}\n```\n\n输出结果：\n\n```\n//电脑是64位的，显示的结果不太一样\n8\n16  //int 4为位，虚函数表8位， 显示16 可能是自动补齐\n```\n\n验证是否有虚函数表存在：\n\n```cpp\nShape shape;\n    cout << sizeof(shape) << endl;\n    //&shape 取得地址符是 Shape类型的指针，要它强转为int指针\n    int *p = (int *) &shape;\n    cout << (unsigned int) (*p) << endl;\n    Circle circle(100);\n    cout << sizeof(circle) << endl;\n    int *q=(int*)&circle;\n    cout << (unsigned int) (*q) << endl;\n    q++;//64位系统 每一次++只前进4位 所以要加两次\n    q++;\n    cout << (unsigned int) (*q) << endl;\n    return 0;\n```\n\n输出结果：\n\n```\n8\n4206848 //地址值\n16\n4206880 //地址值\n100 //int的值\n```\n\n\n"},{"title":"WEB前端 CSS选择器","url":"/2019/03/18/yuque/oxz24f/","content":"<a name=\"e9c05c19\"></a>\n# WEB前端-CSS选择器(CSS背景)\n\n<a name=\"f45b3982\"></a>\n## 交集选择器\n\n> 交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器\n> 注：用的相对来说比较少，不太建议使用。\n\n\n```css\nh3.title{color:red;}\n\n标签下的类名：h3标签下类名叫title\n```\n\n<a name=\"1a726dab\"></a>\n## 并集选择器\n\n> 如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式\n\n\n```css\n比如  .one, p , #test {color: #F00;}  表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。  通常用于集体声明。\n```\n\n<a name=\"12987cb5\"></a>\n## 子元素选择器\n\n> 子元素选择器: 拥有父类的元素称为子元素\n\n\n```css\n.demo > h3 {color: red;}   类名demo下的子标签h3标签\n```\n\n<a name=\"9acd09cf\"></a>\n## 属性选择器\n\n选取标签带有某些特殊属性的选择器\n\n```css\n/* 获取到 拥有 该属性的元素 */\ndiv[class^=font] { /*  class^=font 表示 font 开始位置就行了 */\n\t\t\tcolor: pink;\n\t\t}\ndiv[class$=footer] { /*  class$=footer 表示 footer 结束位置就行了 */\n\t\t\tcolor: skyblue;\n\t\t}\ndiv[class*=tao] { /* class*=tao  *=  表示tao 在任意位置都可以 */\n\t\t\tcolor: green;\n\t\t}\n```\n\n```html\n<div class=\"font12\">属性选择器</div>\n    <div class=\"font12\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"font24\">属性选择器</div>\n    <div class=\"24font\">属性选择器123</div>\n    <div class=\"sub-footer\">属性选择器footer</div>\n    <div class=\"jd-footer\">属性选择器footer</div>\n    <div class=\"news-tao-nav\">属性选择器</div>\n    <div class=\"news-tao-header\">属性选择器</div>\n    <div class=\"tao-header\">属性选择器</div>\n```\n\n<a name=\"5dc052b6\"></a>\n## 伪元素选择器（CSS3)\n\n1. E::first-letter文本的第一个单词或字（如中文、日文、韩文等）\n1. E::first-line 文本第一行；\n1. E::selection 可改变选中文本的样式；\n1. E::before和E::after\n1. 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。\n\n```css\np::first-letter {\n  font-size: 20px;\n  color: hotpink;\n}\n\n/* 首行特殊样式 */\np::first-line {\n  color: skyblue;\n}\n\np::selection {\n  /* font-size: 50px; */\n  color: orange;\n}\ndiv::befor {\n  content:\"开始\";\n}\ndiv::after {\n  content:\"结束\";\n}\n```\n\n<a name=\"acec74dd\"></a>\n## CSS背景\n\n<a name=\"5ed0a02c\"></a>\n### 背景透明(CSS3)\n\nCSS3支持背景半透明的写法语法格式是:\n\n```css\nbackground: rgba(0,0,0,0.3);\n```\n\n最后一个参数是alpha 透明度  取值范围 0~1之间\n\n注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。\n\n<a name=\"f04a2fda\"></a>\n## 背景缩放(CSS3)\n\n通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。\n\n其参数设置如下：\n\na) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）\n\nb) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多\n\nc) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。\n\n```css\nbackground-image: url('images/gyt.jpg');\n\t\t\tbackground-size: 300px 100px;\n\t\t\t/* background-size: contain; */\n\t\t\t/* background-size: cover; */\n```\n\n<a name=\"6f965d12\"></a>\n## 多背景(CSS3)\n\n以逗号分隔可以设置多背景，可用于自适应布局  做法就是 用逗号隔开就好了。\n\n* 一个元素可以设置多重背景图像。\n* 每组属性间使用逗号分隔。\n* 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。\n* 为了避免背景色将图像盖住，背景色通常都定义在最后一组上，\n\n```css\nbackground:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px  ,\n\t   url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,\n\t   url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa;\n```\n\n* <br />\n\n<a name=\"a5683bcb\"></a>\n## 凹凸文字\n\n```css\n<head>\n        <meta charset=\"utf-8\">\n        <style>\n        body {\n        \tbackground-color: #ccc;\n        }\n\t\tdiv {\n\t\t\tcolor: #ccc;\n\t\t\tfont: 700 80px \"微软雅黑\";\n\t\t}\n\t\tdiv:first-child {\n\t\t\t/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */\n\t\t\ttext-shadow: 1px 1px 1px #000, -1px -1px 1px #fff;\n\t\t}\n\t\tdiv:last-child {\n\t\t\t/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */\n\t\t\ttext-shadow: -1px -1px 1px #000, 1px 1px 1px #fff;\n\t\t}\n\n        </style>\n    </head>\n    <body>\n    <div>我是凸起的文字</div>\n    <div>我是凹下的文字</div>\n    </body>\n```\n\n<a name=\"a7b5926d\"></a>\n## CSS 三大特性\n\n<a name=\"fa19d2fa\"></a>\n### CSS层叠性\n\n> 所谓层叠性是指多种CSS样式的叠加。\n> 一般情况下，按照CSS顺序，以最后的样式为准。\n> 1. 样式冲突，遵循的原则是就近原则。\n\n\n<a name=\"478949f9\"></a>\n### CSS继承性\n\n> 所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号\n> 注：子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）\n\n\n<a name=\"e3e6c21b\"></a>\n### CSS优先级\n\n> 继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。\n> 行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。\n> 权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。\n> CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。\n\n\n<a name=\"9a4e4db8\"></a>\n### CSS特殊性（Specificity）\n\n关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：\n\nspecificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。\n\n| 继承或者* 的贡献值 | 0,0,0,0 |\n| --- | --- |\n| 每个元素（标签）贡献值为 | 0,0,0,1 |\n| 每个类，伪类贡献值为 | 0,0,1,0 |\n| 每个ID贡献值为 | 0,1,0,0 |\n| 每个行内样式贡献值 | 1,0,0,0 |\n| 每个!important贡献值 | ∞ 无穷大 |\n\n\n权重是可以叠加的\n\n例子：\n\n```css\ndiv ul  li   ------>      0,0,0,3\n\n.nav ul li   ------>      0,0,1,2\n\na:hover      -----—>      0,0,1,1\n\n.nav a       ------>      0,0,1,1   \n\n#nav p       ----->       0,1,0,1\n```\n\n\n```\n总结优先级：\n\n使用了 !important声明的规则。\n内嵌在 HTML 元素的 style属性里面的声明。\n使用了 ID 选择器的规则。\n使用了类选择器、属性选择器、伪元素和伪类选择器的规则。\n使用了元素选择器的规则。\n只包含一个通用选择器的规则。\n同一类选择器则遵循就近原则。\n\n注意： \n继承的 权重是 0\n数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0。\n```\n\n\n"},{"title":"WEB前端 盒子模型初识","url":"/2019/03/18/yuque/ir3uw4/","content":"<a name=\"5b97da2d\"></a>\n# CSS盒子模型\n\n<a name=\"59721b7c\"></a>\n## 盒子边框（border）\n\n```\nborder : border-width || border-style || border-color\n```\n\n边框属性—设置边框样式（border-style）\n\n边框样式用于定义页面中边框的风格，常用属性值如下：\n\n```\nnone：没有边框即忽略所有边框的宽度（默认值）\n\nsolid：边框为单实线(最为常用的)\n\ndashed：边框为虚线  \n\ndotted：边框为点线\n\ndouble：边框为双实线\n```\n\n<a name=\"f358de9b\"></a>\n### 盒子边框写法总结表\n\n|  |  |  |\n| --- | --- | --- |\n| 设置内容 | 样式属性 | 常用属性值 |\n| 上边框 | border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; |  |\n| 下边框 | border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; |  |\n| 左边框 | border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; |  |\n| 右边框 | border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; |  |\n| 样式综合设置 | border-style:上边 [右边 下边 左边]; | none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 |\n| 宽度综合设置 | border-width:上边 [右边 下边 左边]; | 像素值 |\n| 颜色综合设置 | border-color:上边 [右边 下边 左边]; | 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) |\n| 边框综合设置 | border:四边宽度 四边样式 四边颜色; |  |\n\n\n<a name=\"5cf8ca55\"></a>\n### 表格的细线边框\n\n表格线变粗原因是因为边框重叠\n\ntable{ border-collapse:collapse; }  collapse 单词是合并的意思\n\nborder-collapse:collapse; 表示边框合并在一起。\n\n<a name=\"826aca4e\"></a>\n### 圆角边框(CSS3)\n\n语法格式：\n\n```\nborder-radius: 左上角  右上角  右下角  左下角;\n```\n\n案例:\n\n```css\n<style>\n\t\tdiv {\n\t\t\twidth: 200px;\n\t\t\theight: 200px;\n\t\t\tborder: 1px solid red;\n\t\t}\n\t\tdiv:first-child {  /* 结构伪类选择器 选亲兄弟 */\n\t\t\tborder-radius: 10px;  /*  一个数值表示4个角都是相同的 10px 的弧度 */ \n\t\t}\n\n\t\tdiv:nth-child(2) {\n\t\t\t/*border-radius: 100px;    取宽度和高度 一半  则会变成一个圆形 */\n\t\t\tborder-radius: 50%;   /*  100px   50% 取宽度和高度 一半  则会变成一个圆形 */\n\t\t}\n\n\t\tdiv:nth-child(3) {\n\t\t\tborder-radius: 10px 40px;  /* 左上角  和 右下角  是 10px  右上角 左下角 40 对角线 */\n\t\t}\n\t\t\n\t\tdiv:nth-child(4) {\n\t\t\tborder-radius: 10px 40px  80px;   /* 左上角 10    右上角  左下角 40   右下角80 */\n\t\t}\n\t\tdiv:nth-child(5) {\n\t\t\tborder-radius: 10px 40px  80px  100px;   /* 左上角 10    右上角 40  右下角 80   左下角   右下角100 */\n\t\t}\n\t\tdiv:nth-child(6) {\n\t\t\tborder-radius: 100px;  \n\t\t\theight: 100px; \n\t\t}\n\t\tdiv:nth-child(7) {\n\t\t\tborder-radius: 100px 0;  \n\t\t}\t\n        </style>\n```\n\n<a name=\"3163018c\"></a>\n## 内边距（padding）\n\npadding属性用于设置内边距。  是指 边框与内容之间的距离。\n\npadding-top:上内边距\n\npadding-right:右内边距\n\npadding-bottom:下内边距\n\npadding-left:左内边距\n\n| 值的个数 | 表达意思 |\n| --- | --- |\n| 1个值 | padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 |\n| 2个值 | padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 |\n| 3个值 | padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 |\n| 4个值 | padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 |\n\n\n<a name=\"34f57d30\"></a>\n## 外边距（margin）\n\nmargin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。\n\nmargin-top:上外边距\n\nmargin-right:右外边距\n\nmargin-bottom:下外边距\n\nmargin-left:上外边距\n\nmargin:上外边距 右外边距  下外边距  左外边\n\n取值顺序跟内边距相同。\n\n<a name=\"bd9aeb5a\"></a>\n### 外边距实现盒子居中\n\n可以让一个盒子实现水平居中，需要满足一下两个条件：\n\n1. 必须是块级元素。\n1. 盒子必须指定了宽度（width）\n\n然后就给**左右的外边距都设置为auto**，就可使块级元素水平居中。\n\n实际工作中常用这种方式进行网页布局，示例代码如下：\n\n```\n.header{ width:960px; margin:0 auto;}\n```\n\n<a name=\"64478e4f\"></a>\n### 文字盒子居中图片和背景区别\n\n1. 文字水平居中是  text-align: center\n1. 盒子水平居中  左右margin 改为 auto\n\n```css\ntext-align: center; /*  文字居中水平 */\nmargin: 10px auto;  /* 盒子水平居中  左右margin 改为 auto 就阔以了 */\n```\n\n1. 插入图片 我们用的最多 比如产品展示类\n1. 背景图片我们一般用于小图标背景 或者 超大背景图片\n\n```css\nsection img {  \n\t\twidth: 200px;/* 插入图片更改大小 width 和 height */\n\t\theight: 210px;\n\t\tmargin-top: 30px;  /* 插入图片更改位置 可以用margin 或padding  盒模型 */\n\t\tmargin-left: 50px; /* 插入当图片也是一个盒子 */\n\t}\n\naside {\n\t\twidth: 400px;\n\t\theight: 400px;\n\t\tborder: 1px solid purple;\n\t\tbackground: #fff url(images/sun.jpg) no-repeat;\n\t\n\t\tbackground-size: 200px 210px; /*  背景图片更改大小只能用 background-size */\n\t\tbackground-position: 30px 50px; /* 背景图片更该位置 我用 background-position */\n\t}\n```\n\n<a name=\"fa1b7274\"></a>\n### 清除元素的默认内外边距(兼容浏览器)\n\n为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距：\n\n```css\n* {\n   padding:0;         /* 清除内边距 */\n   margin:0;          /* 清除外边距 */\n}\n```\n\n注意：  行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。\n\n我们尽量不要给行内元素指定上下的内外边距就好了。\n\n<a name=\"48880533\"></a>\n## 外边距合并\n\n使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。\n\n<a name=\"a8b820de\"></a>\n### 相邻块元素垂直外边距的合并\n\n当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。\n\n解决方案：  避免就好了。\n\n<a name=\"890bf71c\"></a>\n### 嵌套块元素垂直外边距的合并\n\n对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。\n\n解决方案：\n\n1. 可以为父元素定义1像素的上边框或上内边距。\n1. 可以为父元素添加overflow:hidden。\n\n待续。。。。\n\n<a name=\"6db19a80\"></a>\n## content宽度和高度\n\n使用宽度属性width和高度属性height可以对盒子的大小进行控制。\n\nwidth和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。\n\n大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：\n\n```css\n/*外盒尺寸计算（元素空间尺寸）*/\n  Element空间高度 = content height + padding + border + margin\n  Element 空间宽度 = content width + padding + border + margin\n  /*内盒尺寸计算（元素实际大小）*/\n  Element Height = content height + padding + border （Height为内容高度）\n  Element Width = content width + padding + border （Width为内容宽度）\n```\n\n注意：\n\n1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。\n\n2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。\n\n3、**如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小**。\n\n\n"},{"title":"RSA+AES请求组合加密","url":"/2019/03/18/yuque/whdmw7/","content":"<a name=\"e2d6d0e3\"></a>\n## 基本概念\n\n> 加密方式分为：`AES(对称加密)`和`RSA(非对称加密)`\n\n\n<a name=\"cc8942e5\"></a>\n### AES算法流程\n\n<a name=\"4f92e2ec\"></a>\n##### 发送方：\n\n1. 创建AES私钥，用口令对私钥加密\n1. 将加密后的私钥发送给接收方\n1. 用私钥加密明文，并将密文和加密后的私钥发给接收方\n\n<a name=\"a9afad8b\"></a>\n##### 接收方：\n\n1. 解密这个私钥\n1. 用解密后的密钥把密文解密成明文\n<a name=\"a1c5aaa2\"></a>\n### RSA算法流程\n\n<a name=\"a9afad8b-1\"></a>\n##### 接收方：\n\n1. 创建RSA密钥对（公钥和私钥）公钥发给发送方，私钥存在接收方。\n1. 接收方用私钥对密文解密\n\n<a name=\"4f92e2ec-1\"></a>\n##### 发送方：\n\n1. 公钥对明文加密，将密文发给接收方\n\n<a name=\"54e51201\"></a>\n## RSA+AES结合加密\n\n<a name=\"a9afad8b-2\"></a>\n##### 接收方：\n\n1. 创建RSA密钥对（公钥、私钥）把公钥发给发送方，自己保存私钥\n1. 用RSA私钥解密加密后的AES密钥，并用AES密钥解密密文，得到明文\n\n<a name=\"4f92e2ec-2\"></a>\n##### 发送方：\n\n1. 创建AES密钥，并用AES加密明文，再用RSA公钥加密AES密钥，并把加密后的AES密钥和密文发送给接收方\n\n<a name=\"129ccec9\"></a>\n## Android RSA+AES加密过程\n\n<a name=\"0844abc0\"></a>\n##### Android：\n\n1. 生成AES密钥，并用AES密钥对明文加密\n1. 使用RSA公钥将AES密钥(aesKey)加密成encryptAesKey，作为HTTP请求头\n1. 将AES加密明文后的密文（encryptData）作为请求体，将请求体和请求头一起发给sever\n\n<a name=\"5c1a77b0\"></a>\n##### sever：\n\n1. 生成RSA密钥对（公钥、私钥）,提供接口给客户端，发送公钥\n1. 获得AES加密后的`请求头（encryptAesKey）`，获得加密后的`请求体（encryptData）`\n1. 使用私钥解密请求头`请求头（encryptAesKey）`获得到AES密钥去`请求体（encryptData）`里的密文\n\n![](https://cdn.nlark.com/yuque/0/2019/png/259158/1552902841850-72dada79-acb1-4e99-bf81-56fad72ef6d9.png#align=left&display=inline&height=1228&originHeight=1228&originWidth=700&size=0&status=done&width=700)\n\n<a name=\"ea6f3b87\"></a>\n## 参考链接\n\n> [我的Android进阶之旅------>Android采用AES+RSA的加密机制对http请求进行加密](http://blog.csdn.net/ouyang_peng/article/details/50983574)\n> [ Android数据加密之RSA+AES混合加密](http://blog.csdn.net/mq2856992713/article/details/52587254)\n> [Android数据加密之Aes加密](http://www.cnblogs.com/whoislcj/p/5473030.html)\n\n\n\n"},{"title":"Android事件传递机制","url":"/2019/03/18/yuque/ph7ndd/","content":"![](https://cdn.nlark.com/yuque/0/2019/jpeg/259158/1552902806606-28de3366-bc92-49b5-a583-185bb639aeb4.jpeg#align=left&display=inline&height=490&originHeight=800&originWidth=1217&size=0&status=done&width=746)\n\n<a name=\"8bdaa6d6\"></a>\n### 事件传递要经的方法\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent ev); //分发事件\npublic boolean onInterceptTouchEvent(MotionEvent ev); //拦截事件\npublic boolean onTouchEvent(MotionEvent ev); //处理事件\n```\n\n<a name=\"f5af0e51\"></a>\n### 事件传递的简介\n\n<a name=\"ViewGroup\"></a>\n##### ViewGroup\n\n接收事件后，进行分发：\n\n1. 如果不进行分发，则`dispatchTouchEvent`返回`true`，事件消亡未处理。\n1. 如果进行分发该事件，则`dispatchTouchEvent`返回`false`，处理或传递该事件：\n\n* 如果想自己处理该事件,则`onInterceptTouchEvent`返回`true`，拦截事件，给自己的`onTouchEvent`进行处理；\n* 如果不想处理该事件，则`onInterceptTouchEvent`返回`false`，把事件传递给子View进行处理。\n\n1. 对于最底层的子View，没有`onInterceptEvent`拦截事件，接收到事件后进行分发：\n\n* 如果不进行分发，则`dispatchTouchEvent`返回`false`，事件未处理，注意这里的最小子view返回`false`代表未分发事件；\n* 如果进行分发该事件，则`dispatchTouchEvent`返回`true`：\n\n1. 如果处理该事件，则`onTouchEvent`返回`true`把该事件消费掉；\n1. 如果不想处理该事件，则`onTouchEvent`返回`false`，等待上级处理。\n\n<a name=\"c9eb9943\"></a>\n##### 需要注意：\n\nviewGroup中包含的最小子view是不含拦截`onInterceptTouchEvent`事件的，最小的子view比如Button,TextView...因为他们已在树的最底层，已无法向下传递了。\n\n\n"},{"title":"Kotlin基本数据类型","url":"/2019/03/18/yuque/bzavq1/","content":"<a name=\"8a276886\"></a>\n# Kotlin数据类型\n\n| type | Bit |\n| --- | --- |\n| Double | 64 |\n| Float | 32 |\n| Long | 64 |\n| Int | 32 |\n| Short | 16 |\n| Byte | 8 |\n\n<a name=\"4056a7ee\"></a>\n## Kotlin八大数组类型\n\n| Type |\n| --- |\n| CharArray |\n| ByteArray |\n| ShortArray |\n| IntArray |\n| FloatArray |\n| DoubleArray |\n|  |\n\n\n```java\n常量 定义：val FINAL_HELLO_WORLD: String = \"Hello World\"  //val\n```\n\n```java\n变量定义：var text: String = hello  //var\n```\n\n```javascript\nvar text: String? = helloWorld   //String 类型\n```\n\n```javascript\nval textArray: Array<Char> = arrayOf('H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd')   // Char 字符数组\n```\n\n```javascript\nval helloWorldCharArray: CharArray = charArrayOf('H', 'e', 'l', 'l', 'o', 'W', 'o', 'r', 'l', 'd')  //Kotlin 类型的字符数组\n```\n\n```javascript\nval helloWorldLength: Int = helloWorld.length  //字符长度 int类型\n```\n\n```javascript\nval helloWorldLengthLong: Long = helloWorldLength.toLong()  //字符长度转换为Long 类型\n```\n\n\n"},{"title":"const与基本数据类型","url":"/2019/03/18/yuque/ugsunf/","content":"<a name=\"04d4332e\"></a>\n# const修饰符\n\n<a name=\"8a84cc7e\"></a>\n## const与基本数据类型\n\nconst int x=3； //常量\n\n| 变量名 | 存储地址 | 存储内容 |\n| :---: | :---: | :---: |\n| x | &x | 3（不可更改的值） |\n\n\n<a name=\"a72ccb57\"></a>\n## const与指针类型\n\n> 对号 代表等价\n\n\n- [x] const int *p =NULL ；\n- [x] int const *p=NuLL;\n- [ ] int* const p=NULL；\n- [x] const int* const p=NULL;\n- [x] int const* const p=NULL;\n\n例子：\n\n`int x=3; const int *p=&x;`\n\n`p=&y;正确 *p=4；错误`\n\n因为const修饰的是_p而不是p，所以p可以更改值，而 _p不能更改值。\n\n| 变量名 | 存储地址 | 存储内容 |\n| :---: | :---: | :---: |\n| x | &x | 3 |\n| p | &p | &x |\n\n\n`const修饰符修饰谁，谁就不能变。`\n\n<a name=\"1f9cfa6f\"></a>\n## 内存的申请和释放\n\n申请内存运算符\n\n关键词 new detle\n\n\n"},{"title":"Git命令","url":"/2019/03/18/yuque/qbu9z0/","content":"1. **生成ssh私钥**\n\n```\n$ git config --list //查看当前全局配置\n$ git config --global user.name \"用户名\"\n$ git config --global user.email \"邮箱\"\n```\n\n1. **生成ssh密钥：**\n\n```\n$ ssh-keygen -t rsa -C “邮箱”\n```\n\n1. **克隆项目**\n\n```\ngit clone\n```\n\n\n"},{"title":"C++ RTTI","url":"/2019/03/18/yuque/fqaa2q/","content":"RTTI（Run-Time Type Identification)运行时类型识别，类似JAVA中的多态\n> 父类接口类：\n\n\n```cpp\nclass Person {\npublic:\n   virtual void eat()=0;\n   virtual void run()=0;\n};\n```\n\n子类实现\n\n```cpp\n//继承并实现\nclass Teacher : public Person {\npublic:\n   void Study();\n   virtual void eat();\n   virtual void run();\n};\nclass Student : public Person {\npublic:\n   void play();\n   virtual void eat();\n   virtual void run();\n};\n//.cpp 实现\nvoid Teacher::run() {\n   cout << \"Teacher::run()\" << endl;\n}\nvoid Teacher::eat() {\n   cout << \"Teacher::eat()\" << endl;\n}\nvoid Teacher::Study() {\n   cout << \"Teacher::Study()\" << endl;\n}\nvoid Student::run() {\n   cout << \"Student::run()\" << endl;\n}\nvoid Student::eat() {\n   cout << \"Student::eat()\" << endl;\n}\nvoid Student::play() {\n   cout << \"Student::play()\" << endl;\n}\n```\n\n```cpp\nvoid Test(Person *obj) {\n   cout << typeid(*obj).name() << endl;\n   obj->run();\n   if (typeid(*obj) == typeid(Student)) {\n       Student *student = dynamic_cast<Student *>(obj);\n       student->play();\n   }\n   if (typeid(*obj) == typeid(Teacher)) {\n       Teacher *teacher = dynamic_cast<Teacher *>(obj);\n       teacher->Study();\n   }\n   obj->eat();\n}\nint main() {\n   Student student;\n   Test(&student);\n   return 0;\n}\n```\n\n结果：\n\n```\n7Student\nStudent::run()\nStudent::play()\nStudent::eat()\n```\n\n类型转换：\n\n> 如果子类必须含有虚函数，否则不是多态，其次，必须事引用和指针才能类型转换\n> 如下：\n\n\n```cpp\n//父类去掉纯虚函数\nclass Person {\npublic:\n   void eat();\n   void run();\n};\n```\n\n```cpp\n//子类没有虚函数\nclass Student : public Person {\npublic:\n   void play();\n   void eat();\n   void run();\n};\n```\n\n```cpp\nint main() {\n   Person *person = new Student();\n   //子类必须含有虚函数，否则不是多态。其次，必须是引用和指针才能类型转换\n   Student *s = dynamic_cast<Student *>(person); //直接报错，错误原因是：person 不是多态类型\n   return 0;\n}\n```\n\n\n"},{"title":"C++ STL标准模板库","url":"/2019/03/18/yuque/dggnmz/","content":"<a name=\"be282fff\"></a>\n# C++ STL（标准模板库）\n\n> C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。\n\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件 | 描述 |\n| --- | --- |\n| 容器（Containers） | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms） | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n\n例子:\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n \nint main()\n{\n   // 创建一个向量存储 int\n   vector<int> vec; \n   int i;\n \n   // 显示 vec 的原始大小\n   cout << \"vector size = \" << vec.size() << endl;\n \n   // 推入 5 个值到向量中\n   for(i = 0; i < 5; i++){\n      vec.push_back(i);\n   }\n \n   // 显示 vec 扩展后的大小\n   cout << \"extended vector size = \" << vec.size() << endl;\n \n   // 访问向量中的 5 个值\n   for(i = 0; i < 5; i++){\n      cout << \"value of vec [\" << i << \"] = \" << vec[i] << endl;\n   }\n \n   // 使用迭代器 iterator 访问值\n   vector<int>::iterator v = vec.begin();\n   while( v != vec.end()) {\n      cout << \"value of v = \" << *v << endl;\n      v++;\n   }\n \n   return 0;\n}\n```\n\n输出结果：\n\n```\nvector size = 0\nextended vector size = 5\nvalue of vec [0] = 0\nvalue of vec [1] = 1\nvalue of vec [2] = 2\nvalue of vec [3] = 3\nvalue of vec [4] = 4\nvalue of v = 0\nvalue of v = 1\nvalue of v = 2\nvalue of v = 3\nvalue of v = 4\n```\n\n关于上面实例中所使用的各种函数，有几点要注意：\n\n* push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。\n* size( ) 函数显示向量的大小。\n* begin( ) 函数返回一个指向向量开头的迭代器。\n* end( ) 函数返回一个指向向量末尾的迭代器。\n\n\n"},{"title":"C++ 模板函数","url":"/2019/03/18/yuque/qkf8tp/","content":"<a name=\"f288c32f\"></a>\n# C++模板函数\n\n> 类似JAVA中的泛型，可以实例化多种参数类型的模板\n\n\n```cpp\ntemplate <typename  T> //typename 和 class 都是一样的\nvoid display(T a){\n    cout<<a<<endl;\n}\ntemplate  <typename T,class S>\nvoid display(T t,S s){\n    cout<<t<<endl;\n    cout<<s<<endl;\n};\ntemplate <typename  T, int Ksize>\nvoid display(T a){\n    for (int i = 0; i < Ksize; ++i) {\n        cout<<a<<endl;\n    }\n};\n\nint main() {\n//    display<int>(10.89); //显示调用\n    display(10,29.2);\n    return 0;\n    \n}\n```\n\n\n"},{"title":"C++ 虚函数","url":"/2019/03/18/yuque/rzuyu3/","content":"<a name=\"32938275\"></a>\n# C++虚函数\n\n> 父类函数不加virtual关键词，子类继承后，当父类指针指向子类指针，同样的函数，会执行父类的函数。子类的函数实际是被隐藏了，如果用子类的指针指向自己的话，是能够执行的。\n\n\n```cpp\n#include <iostream>\n/**\n * C++多态 虚函数\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    double calcArea();\n\n};\n\n\nclass Circle : public Shape {\npublic:\n    Circle(double r);\n\n    ~Circle();\n\n    double calcArea();\n\nprotected:\n    double m_dR;\n\nprotected:\n    string m_strName;\n};\n\n\nclass Rect : public Shape {\npublic:\n    Rect(double width, double height);\n\n    ~Rect();\n\n    double calcArea();\n\nprotected:\n    double m_dWidth;\n    double m_dHeight;\n};\n\nRect::Rect(double width, double height) {\n    m_dHeight = height;\n    m_dWidth = width;\n    cout << \"Rect::Rect()\" << endl;\n}\n\ndouble Rect::calcArea() {\n\n    cout << \"Rect::calcArea()\" << endl;\n    return m_dWidth*m_dHeight;\n}\n\nRect::~Rect() {\n    cout << \"~Rect()\" << endl;\n}\n\nCircle::Circle(double r) {\n    m_dR = r;\n    cout << \"Circle()\" << endl;\n}\n\ndouble Circle::calcArea() {\n    cout << \"Circle::calcArea()\" << endl;\n    return 3.14 * m_dR * m_dR;\n}\n\nCircle::~Circle() {\n    cout << \"~Circle()\" << endl;\n}\n\nShape::Shape() {\n    cout << \"Shape()\" << endl;\n}\n\nShape::~Shape() {\n    cout << \"~Shape()\" << endl;\n}\n\ndouble Shape::calcArea() {\n    cout << \"Shape::clacArea()\" << endl;\n}\n\n\nint main() {\n    Shape *shape=new Rect(3,6);\n    Shape *shape1=new Circle(5);\n    shape->calcArea();\n    shape1->calcArea();\n    delete(shape);\n    delete(shape1);\n    return 0;\n}\n```\n\n运行的结果\n\n```\nShape()\nRect::Rect()\nShape()\nCircle()\nShape::clacArea() //父类的方法\nShape::clacArea() //父类的方法\n~Shape()\n~Shape()\n```\n\n<a name=\"b95e70aa\"></a>\n## 加上virtual关键词后\n\n```cpp\n#include <iostream>\n/**\n * C++多态 虚函数\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    virtual double calcArea();\n\n};\n\n//虚继承\nclass Circle : public Shape {\npublic:\n    Circle(double r);\n\n    ~Circle();\n\n    double calcArea();\n\nprotected:\n    double m_dR;\n\nprotected:\n    string m_strName;\n};\n\n//虚继承\nclass Rect : public Shape {\npublic:\n    Rect(double width, double height);\n\n    ~Rect();\n\n    double calcArea();\n\nprotected:\n    double m_dWidth;\n    double m_dHeight;\n};\n\nRect::Rect(double width, double height) {\n    m_dHeight = height;\n    m_dWidth = width;\n    cout << \"Rect::Rect()\" << endl;\n}\n\ndouble Rect::calcArea() {\n\n    cout << \"Rect::calcArea()\" << endl;\n    return m_dWidth*m_dHeight;\n}\n\nRect::~Rect() {\n    cout << \"~Rect()\" << endl;\n}\n\nCircle::Circle(double r) {\n    m_dR = r;\n    cout << \"Circle()\" << endl;\n}\n\ndouble Circle::calcArea() {\n    cout << \"Circle::calcArea()\" << endl;\n    return 3.14 * m_dR * m_dR;\n}\n\nCircle::~Circle() {\n    cout << \"~Circle()\" << endl;\n}\n\nShape::Shape() {\n    cout << \"Shape()\" << endl;\n}\n\nShape::~Shape() {\n    cout << \"~Shape()\" << endl;\n}\n\ndouble Shape::calcArea() {\n    cout << \"Shape::clacArea()\" << endl;\n}\n\n\nint main() {\n    Shape *shape=new Rect(3,6);\n    Shape *shape1=new Circle(5);\n    shape->calcArea();\n    shape1->calcArea();\n    delete(shape);\n    delete(shape1);\n    return 0;\n}\n```\n\n运行结果\n\n```\nShape()\nRect::Rect()\nShape()\nCircle()\nRect::calcArea() //子类自己的函数\nCircle::calcArea()//子类自己的函数\n~Shape()\n~Shape()\n```\n\n\n"},{"title":"C++ 虚析构函数","url":"/2019/03/18/yuque/yk01ls/","content":"<a name=\"f41bd17f\"></a>\n# C++虚析构函数\n\n> 防止内存泄露\n> 子类继承父类后，在子类构造函数里，通过new 来生成一个对象实例\n> 在析构函数里执行释放内存操作，如果父类不加上virtual 关键词\n> 则子类执行的是父类的析构函数，不执行自己的析构函数。\n\n\n父类不加virtual  子类继承后，并执行析构函数：\n\n```cpp\n#include <iostream>\n/**\n * C++多态 虚析构函数 （防止内存泄露）\n */\n\nusing namespace std;\n\n//形状\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    virtual double calcArea();\n\n};\nclass Coordinate {\npublic:\n    Coordinate(int x, int y);\n\n    ~Coordinate();\n\nprotected:\n    int m_iX;\n    int m_iY;\n};\n\n//Circle继承Shape\nclass Circle : public Shape {\npublic:\n    Circle(double r);\n\n    ~Circle();\n\n    double calcArea();\n\nprotected:\n    double m_dR;\n    Coordinate *coordinate;\n\nprotected:\n    string m_strName;\n};\n\n//Rect继承Shape\nclass Rect : public Shape {\npublic:\n    Rect(double width, double height);\n\n    ~Rect();\n\n    double calcArea();\n\nprotected:\n    double m_dWidth;\n    double m_dHeight;\n};\n\n\n\nCoordinate::Coordinate(int x, int y) {\n    cout << \"Coordinate()\" << endl;\n    m_iX = x;\n    m_iY = y;\n}\n\nCoordinate::~Coordinate() {\n    cout << \"~Coordinate()\" << endl;\n}\n\nRect::Rect(double width, double height) {\n    m_dHeight = height;\n    m_dWidth = width;\n    cout << \"Rect::Rect()\" << endl;\n}\n\ndouble Rect::calcArea() {\n\n    cout << \"Rect::calcArea()\" << endl;\n    return m_dWidth * m_dHeight;\n}\n\nRect::~Rect() {\n    cout << \"~Rect()\" << endl;\n}\n\nCircle::Circle(double r) {\n    m_dR = r;\n    coordinate=new Coordinate(5,5);\n    cout << \"Circle()\" << endl;\n}\n\ndouble Circle::calcArea() {\n    cout << \"Circle::calcArea()\" << endl;\n    return 3.14 * m_dR * m_dR;\n}\n\nCircle::~Circle() {\n    delete(coordinate);//释放内存\n    cout << \"~Circle()\" << endl;\n}\n\nShape::Shape() {\n    cout << \"Shape()\" << endl;\n}\n\nShape::~Shape() {\n    cout << \"~Shape()\" << endl;\n}\n\ndouble Shape::calcArea() {\n    cout << \"Shape::clacArea()\" << endl;\n}\n\n\nint main() {\n    Shape *shape = new Rect(3, 6);\n    Shape *shape1 = new Circle(5);\n    shape->calcArea();\n    shape1->calcArea();\n    delete (shape); //释放内存\n    delete (shape1);//释放内存\n    return 0;\n}\n```\n\n输出结果：\n\n```\nShape()\nRect::Rect()\nShape()\nCoordinate()\nCircle()\nRect::calcArea()\nCircle::calcArea()\n~Shape()\t//父类析构被执行了两次\n~Shape()\t//父类析构被执行了两次\n```\n\n父类加上virtual关键词后，子类执行析构函数：\n\n```cpp\nclass Shape {\npublic:\n    Shape();\n\n    virtual ~Shape();\t//父类加上virtual\n\n    virtual double calcArea();\n\n};\n```\n\n输出结果：\n\n```\nShape()\nRect::Rect()\nShape()\nCoordinate()\nCircle()\nRect::calcArea()\nCircle::calcArea()\n~Rect()\t\t//子类析构函数被执行\n~Shape()\n~Coordinate() //子类析构函数被执行\n~Circle()\t//子类析构函数被执行\n~Shape()\n```\n\n<a name=\"493ba8c6\"></a>\n## virtual关键词限制\n\n1.普通函数不能被修饰（类外面单独提供的方法）\n\n2.静态成员不能被修饰\n\n3.内联函数不能被修饰（会导致内联函数失效）\n\n\n"},{"title":"C++ 友元","url":"/2019/03/18/yuque/xcz284/","content":"<a name=\"864b1559\"></a>\n# C++友元\n\n<a name=\"721f3b13\"></a>\n## 友元函数：\n\n```cpp\nclass Time {\n    friend void printTime(Time &t);\npublic:\n    Time(int hour, int min, int sec);\n\nprivate:\n    int m_hour;\n    int m_min;\n    int m_sec;\n\n};\n```\n\n```c\nTime::Time(int hour, int min, int sec) {\n    m_hour=hour;\n    m_min=min;\n    m_sec=sec;\n}\n```\n\n测试：\n\n```cpp\nvoid printTime(Time &t){\n    cout <<t.m_hour<<\":\"<<t.m_min<<\":\"<<t.m_sec<<endl;\n}\n\nint main() {\n    Time t(4,5,6) ;\n    printTime(t);\n    return 0;\n}\n```\n\n<a name=\"8c539cf6\"></a>\n## 友元类\n\n```cpp\n#include <iostream>\n#include <typeinfo>\n/**\n * 友元函数\n */\n\nusing namespace std;\n\nclass Match;\n\nclass Time {\n    friend Match;//友元类的声明\npublic:\n    Time(int hour, int min, int sec);\n\n\nprivate:\n    void printTime();\n\n    int m_hour;\n    int m_min;\n    int m_sec;\n\n};\n\nclass Match {\npublic:\n    Match(int hour, int min, int sec);\n\n    void testTime();\n\nprivate:\n    Time m_timer;\n    int m_hour;\n    int m_min;\n    int m_sec;\n};\n\nTime::Time(int hour, int min, int sec) {\n    m_hour = hour;\n    m_min = min;\n    m_sec = sec;\n}\n\nvoid Time::printTime() {\n    cout << m_hour << \":\" << m_min << \":\" << m_sec << endl;\n}\n\nMatch::Match(int hour, int min, int sec) : m_timer(hour, min, sec) {\n\n}\n\nvoid Match::testTime() {\n    m_timer.printTime();\n    cout << m_hour << \":\" << m_min << \":\" << m_sec << endl;\n}\n\nint main() {\n    Match m(5, 43, 33);\n    m.testTime();\n    return 0;\n}\n```\n\n\n"},{"title":"C++ 运算符重载","url":"/2019/03/18/yuque/cson21/","content":"<a name=\"bf912185\"></a>\n# C++ 运算符重载\n\n> 运算符重载关键词`operator`\n> 相当于可以把运算符 重新定义为新的运算逻辑，例如之前的+ 号可以 运算int类型\n> 如果重载这个+号，可以实现两个对象相加。\n\n\n例子一：\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n\n//.h 声明\n//纯虚函数 只是头文件 没有cpp，没有实现类\nclass Person{\n    friend  Person &operator-(Person &p); //友元运算符重载\npublic:\n    Person(int x ,int y);\n//    Person &operator-();//运算符重载\n    int getX();\n    int getY();\n\nprivate:\n    int m_iX;\n    int m_iY;\n\n};\n\n\n//cpp  这叫定义\nPerson::Person(int x, int y) {\n    m_iX=x;\n    m_iY=y;\n}\nint Person::getX() {\n    return m_iX;\n}\nint Person::getY() {\n    return m_iY;\n}\nPerson& operator-(Person &p) {\n    p.m_iY=-p.m_iY;\n    p.m_iX=-p.m_iX;\n    return p;\n}\n\n//运算符重载\n//Person& Person::operator-() {\n//    this->m_iX=-(this->m_iX);\n//    m_iY=-m_iY;\n//    return  *this;\n//}\n\n\nint main() {\n    Person p(1,2);\n    cout<<p.getY()<<endl;\n    cout<<p.getX()<<endl;\n    -p;\n    cout<<p.getY()<<endl;\n    cout<<p.getX()<<endl;\n    return 0;\n}\n```\n\n例子二：\n\n```cpp\ninclude <iostream>\nusing namespace std;\n \nclass Box\n{\n   public:\n \n      double getVolume(void)\n      {\n         return length * breadth * height;\n      }\n      void setLength( double len )\n      {\n          length = len;\n      }\n \n      void setBreadth( double bre )\n      {\n          breadth = bre;\n      }\n \n      void setHeight( double hei )\n      {\n          height = hei;\n      }\n      // 重载 + 运算符，用于把两个 Box 对象相加\n      Box operator+(const Box& b)\n      {\n         Box box;\n         box.length = this->length + b.length;\n         box.breadth = this->breadth + b.breadth;\n         box.height = this->height + b.height;\n         return box;\n      }\n   private:\n      double length;      // 长度\n      double breadth;     // 宽度\n      double height;      // 高度\n};\n// 程序的主函数\nint main( )\n{\n   Box Box1;                // 声明 Box1，类型为 Box\n   Box Box2;                // 声明 Box2，类型为 Box\n   Box Box3;                // 声明 Box3，类型为 Box\n   double volume = 0.0;     // 把体积存储在该变量中\n \n   // Box1 详述\n   Box1.setLength(6.0); \n   Box1.setBreadth(7.0); \n   Box1.setHeight(5.0);\n \n   // Box2 详述\n   Box2.setLength(12.0); \n   Box2.setBreadth(13.0); \n   Box2.setHeight(10.0);\n \n   // Box1 的体积\n   volume = Box1.getVolume();\n   cout << \"Volume of Box1 : \" << volume <<endl;\n \n   // Box2 的体积\n   volume = Box2.getVolume();\n   cout << \"Volume of Box2 : \" << volume <<endl;\n \n   // 把两个对象相加，得到 Box3\n   Box3 = Box1 + Box2;\n \n   // Box3 的体积\n   volume = Box3.getVolume();\n   cout << \"Volume of Box3 : \" << volume <<endl;\n \n   return 0;\n}\n```\n\n\n"},{"title":"C++ 类模板","url":"/2019/03/18/yuque/cnuhh0/","content":"<a name=\"725df33a\"></a>\n# C++类模板\n\n> 类模板 函数声明和函数实现必须写一个文件里\n> 实现的函数，必须加上template<typename T, int Ksiez, int Kval> 这样的定义\n\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n\n//.h 声明\ntemplate<typename T, int Ksiez, int Kval>\nclass Myarray {\npublic:\n    Myarray();\n\n    ~Myarray() {\n        delete mpArr;\n    }\n\n    void display();\n\nprivate:\n    T *mpArr;\n};\n\n//cpp  这叫定义\ntemplate<typename T, int Ksiez, int Kval>\nMyarray<T, Ksiez, Kval>::Myarray() {\n    mpArr = new T[Ksiez];\n    for (int i = 0; i < Ksiez; ++i) {\n        mpArr[i] = Kval;\n    }\n}\ntemplate<typename T, int Ksiez, int Kval>\nvoid Myarray<T,Ksiez,Kval>::display() {\n    for (int i = 0; i < Ksiez; ++i) {\n        cout<<mpArr[i]<<endl;\n    }\n}\n\nint main() {\n    Myarray<int,5,6> myarray;\n    myarray.display();\n    return 0;\n\n}\n```\n\n\n"},{"title":"C++ 虚继承","url":"/2019/03/18/yuque/zoa2yv/","content":"如果不虚继承的话，父类对象每一次被调用都会被初始化\n\n```cpp\n#include <iostream>\n/**\n * C++多重继承\n */\n\nusing namespace std;\nclass Person {\npublic:\n    Person(string color=\"blue\");\n    virtual ~Person();\n    void printColor();\nprotected:\n    string m_strColor;\n};\n//虚继承\nclass Farmer :virtual public Person{\npublic:\n    Farmer(string name = \"jack\",string color=\"blue\");\n\n    ~Farmer();\n\n    void sow();\n\nprotected:\n    string m_strName;\n};\n//虚继承\nclass Worker :virtual public Person{\npublic:\n    Worker(string code = \"001\",string color=\"bule\");\n\n    virtual ~Worker();\n\n    void carry();\n\nprotected:\n    string m_strCode;\n};\n\nvoid Worker::carry() {\n    cout << m_strCode << endl;\n    cout << \"Worker::carry()\" << endl;\n}\n\nclass MigrantWorker : public Farmer, public Worker {\npublic:\n    MigrantWorker(string name, string age,string color);\n\n    ~MigrantWorker();\n};\n\n\nPerson::Person(string color) {\n    m_strColor=color;\n    cout << \"Person()\" << endl;\n}\nvoid Person::printColor() {\n    cout << m_strColor << endl;\n    cout << \"Person::printColor()\" << endl;\n}\nPerson::~Person() {\n    cout << \"~Person()\" << endl;\n}\n\nFarmer::Farmer(string name,string color):Person(color) {\n    m_strName = name;\n    cout << \"Farmer()\" << endl;\n}\n\nFarmer::~Farmer() {\n    cout << \"~Farmer()\" << endl;\n}\n\nvoid Farmer::sow() {\n    cout << m_strName << endl;\n    cout << \"Farmer::sow()\" << endl;\n}\n\nWorker::~Worker() {\n    cout << \"~Worker()\" << endl;\n}\n\nWorker::Worker(string code,string color):Person(color){\n    m_strCode = code;\n    cout << \"Worker()\" << endl;\n}\n\nMigrantWorker::MigrantWorker(string name, string code,string color) : Farmer(name,color), Worker(code,color) {\n    cout << \"MigrantWorker()\" << endl;\n}\n\nMigrantWorker::~MigrantWorker() {\n    cout << \"~MigrantWorker()\" << endl;\n}\n\nint main() {\n    MigrantWorker *migrantWorker = new MigrantWorker(\"kitty\", \"002\",\"green\");\n    migrantWorker->carry();\n    migrantWorker->sow();\n    delete (migrantWorker);\n    return 0;\n}\n```\n\n<a name=\"1ad17a64\"></a>\n## 不加virtual关键词 输出结果\n\n```\nPerson 被初始化了两次\nPerson()\nFarmer()\nPerson()\nWorker()\nMigrantWorker()\n002\nWorker::carry()\nkitty\nFarmer::sow()\n~MigrantWorker()\n~Worker()\n~Person()\n~Farmer()\n~Person()\n```\n\n\n"},{"title":"C++ 静态","url":"/2019/03/18/yuque/yvurxt/","content":"<a name=\"a7299f47\"></a>\n# C++静态（static）\n\n> 和JAVA中的静态差不多\n> 静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。\n> 因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。\n> 使用静态数据成员可以节省内存,不占用内存，只有在实现的时候，才会占用内存\n\n\n**声明静态成员的时候，需要加static关键词**\n\n**静态成员初始化，需要在实现里初始化，不能再头文件里初始化**\n\n**静态不能被const修饰，否则编译错误**\n\n```cpp\nclass StaticTest\n{\npublic:\n    StaticTest(int a, int b, int c);\n    void GetNumber();\n    void GetSum();\n    static void f1(StaticTest &s); //静态函数\nprivate:\n    int A, B, C;\n    static int Sum; //静态成员数据\n};\n\n\n\n#include \"StaticTest.h\"\n#include <iostream>\nusing namespace std;\n\nint StaticTest::Sum = 0;//静态成员在此初始化\n\nStaticTest::StaticTest(int a, int b, int c)\n{\n    A = a;\n    B = b;\n    C = c;\n    Sum += A + B + C;\n}\n\nvoid StaticTest::GetNumber()\n{\n    cout << \"Number = \" << endl;\n}\n\nvoid StaticTest::GetSum()\n{\n    cout << \"Sum = \" << Sum <<endl;\n}\n\nvoid StaticTest::f1(StaticTest &s)\n{\n    \n    cout << s.A << endl;//静态方法不能直接调用一般成员，可以通过对象引用实现调用\n    cout << Sum <<endl;\n}\n\n#include \"StaticTest.h\"\n#include <stdlib.h>\n\n\nint main(void)\n{\n    StaticTest M(3, 7, 10), N(14, 9, 11);\n    M.GetNumber();\n    N.GetSum();\n    M.GetNumber();\n    N.GetSum();\n    StaticTest::f1(M);\n    system(\"pause\");\n    return 0;\n}\n```\n\n\n"},{"title":"C++ 接口类","url":"/2019/03/18/yuque/xtdyib/","content":"<a name=\"fc8a7f77\"></a>\n# C++接口类\n\n> 如果一个类里面只有纯虚函数，没有其他成员函数和数据成员，就是接口类。\n\n\n<a name=\"9fa44333\"></a>\n## 接口类：\n\n```c\nclass Person {\npublic:\n    virtual void eat()=0;//纯虚函数\n\n    virtual void run()=0;//纯虚函数\n};\n```\n\n<a name=\"841fa534\"></a>\n## 实现类：\n\n> Teacher 继承自接口类Person，并实现Person纯虚函数\n\n\n```cpp\n//.h定义\nclass Teacher :public Person{\npublic:\n\n    virtual void eat();\n\n    virtual void run();\n\n    Teacher(string code);\n\n    void printCode();\n\nprotected:\n    string m_strCode;\n};\n//.cpp 实现\nvoid Teacher::eat() {\n    cout<<\"Teacher::eat()\"<<endl;\n}\nvoid Teacher::run() {\n    cout<<\"Teacher::run()\"<<endl;\n}\nvoid Teacher::printCode() {\n    cout << \"Teacher::printCode: \" << m_strCode << endl;\n}\n```\n\n> Student类继承自Teacher，相当于有两个父类\n\n\n```cpp\n//.h 定义\nclass Student : public Teacher {\npublic:\n    Student(string code);\n\n    virtual void eat();\n\n    virtual void run();\n\n};\n//.cpp 实现\n\nvoid Student::run() {\n    cout << \"Student::run()\" << endl;\n}\n\nStudent::Student(string code) : Teacher(code) { //列表参数初始化\n\n}\n\nvoid Student::eat() {\n    cout << \"Student::eat()\" << endl;\n}\n```\n\n<a name=\"f7be1f51\"></a>\n## 测试：\n\n```cpp\nvoid personTest(Person *p1, Person *p2) {\n    p1->eat();\n    p1->run();\n    p2->eat();\n    p2->run();\n}\n\nint main() {\n    Student p1(\"001\");\n    Student p2(\"002\");\n    \n    p1.printCode();\n    p2.printCode();\n\n    personTest(&p1, &p2);\n\n    return 0;\n}\n```\n\n<a name=\"2ba39675\"></a>\n## 输出结果：\n\n```\nTeacher::printCode: 001\nTeacher::printCode: 002\nStudent::eat()\nStudent::run()\nStudent::eat()\nStudent::run()\n```\n\n<a name=\"c1e96c9b\"></a>\n## 改进：\n\n> 让Student 有两个父类，多重继承\n\n\n```c\nclass Teacher { //Teacher 不继承接口类Person\npublic:\n\n    Teacher(string code);\n\n    void printCode();\n\nprotected:\n    string m_strCode;\n};\n```\n\n```c\nclass Student : public Teacher ,public Person{ //由Student类来继承自接口类，并实现\npublic:\n    Student(string code);\n\n    virtual void eat();\n\n    virtual void run();\n\n};\n```\n\n<a name=\"b27d3ead\"></a>\n## 改进后测试:\n\n```cpp\nvoid personTest(Teacher *p1, Teacher *p2) {\n\n    p1->printCode();\n    p2->printCode();\n\n}\n\nint main() {\n    Student p1(\"001\");\n    Student p2(\"002\");\n\n    personTest(&p1, &p2);\n\n    return 0;\n}\n```\n\n<a name=\"2ba39675-1\"></a>\n## 输出结果：\n\n```\nTeacher::printCode: 001\nTeacher::printCode: 002\n```\n\n\n"},{"title":"C++ 多重继承","url":"/2019/03/18/yuque/nokfhz/","content":"<a name=\"71680096\"></a>\n# C++多重继承\n\n```cpp\n#include <iostream>\n/**\n * C++多重继承\n */\n\nusing namespace std;\n\nclass Farmer {\npublic:\n    Farmer(string name = \"jack\");\n\n    ~Farmer();\n\n    void sow();\n\nprotected:\n    string m_strName;\n};\n\nclass Worker {\npublic:\n    Worker(string code = \"001\");\n\n    virtual ~Worker();\n\n    void carry();\n\nprotected:\n    string m_strCode;\n};\n\nvoid Worker::carry() {\n    cout << m_strCode << endl;\n    cout << \"Worker::carry()\" << endl;\n}\n\nclass MigrantWorker : public Farmer, public Worker {\npublic:\n    MigrantWorker(string name, string age);\n\n    ~MigrantWorker();\n};\nFarmer::Farmer(string name) {\n    m_strName=name;\n    cout << \"Farmer()\" << endl;\n}\nFarmer::~Farmer() {\n    cout << \"~Farmer()\" << endl;\n}\nvoid Farmer::sow() {\n    cout << m_strName << endl;\n    cout << \"Farmer::sow()\" << endl;\n}\nWorker::~Worker() {\n    cout << \"~Worker()\" << endl;\n}\n\nWorker::Worker(string code) {\n    m_strCode = code;\n    cout << \"Worker()\" << endl;\n}\n//初始化列表的方式来初始化 name的值 和code 的值\n//类似：student::student( string name): m_name(name)  将有值的数据 传递给（）内的变量\nMigrantWorker::MigrantWorker(string name, string code) : Farmer(name), Worker(code) {\n    cout << \"MigrantWorker()\" << endl;\n}\n\nMigrantWorker::~MigrantWorker() {\n    cout << \"~MigrantWorker()\" << endl;\n}\n\nint main() {\n    MigrantWorker * migrantWorker=new MigrantWorker(\"kitty\",\"002\");\n    migrantWorker->carry();\n    migrantWorker->sow();\n    delete(migrantWorker);\n    return 0;\n}\n```\n\n\n"},{"title":"C++ 多继承","url":"/2019/03/18/yuque/uy76br/","content":"<a name=\"034a2dba\"></a>\n# C++多继承\n\n> 构造函数，先执行父类的构造函数依次执行，销毁对象，是按照初识化构造函数顺序，倒叙执行。\n\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n\n//.h 声明\nclass Person {\npublic:\n    void play();\n\n    Person(string name = \"kitty\");\n\n    virtual ~Person();\n\nprotected:\n    string m_strName;\n};\n\nclass Soldier : public Person {\npublic:\n    Soldier(string name = \"james\", int age = 20);\n\n    void work();\n\n    virtual ~Soldier();\n\nprotected:\n    int m_iAge;\n};\n\nclass Infantry : public Soldier {\npublic:\n    Infantry(string name = \"jack\", int age = 30);\n\n    void attack();\n\n    virtual ~Infantry();\n};\n\n//cpp  这叫定义\nvoid Person::play() {\n    cout << \"Person::play()\" << endl;\n    cout << m_strName << endl;\n\n}\n\nPerson::~Person() {\n    cout << \"~Person()\" << endl;\n}\n\nPerson::Person(string name) {\n    m_strName = name;\n    cout << \"Person()\" << endl;\n}\n\nSoldier::Soldier(string name, int age) {\n    m_strName = name;\n    m_iAge = age;\n    cout << \"Soldier()\" << endl;\n}\n\nSoldier::~Soldier() {\n    cout << \"~Soldier()\" << endl;\n}\n\nvoid Soldier::work() {\n    cout << m_strName << endl;\n    cout << m_iAge << endl;\n    cout << \"Soldier::work()\" << endl;\n}\n\nInfantry::Infantry(string name, int age) {\n    m_strName = name;\n    m_iAge = age;\n    cout << \"Infantry()\" << endl;\n}\n\nInfantry::~Infantry() {\n    cout << \"~Infantry()\" << endl;\n}\n\nvoid Infantry::attack() {\n    cout << m_strName << endl;\n    cout << m_iAge << endl;\n    cout << \"Infantry::attack()\" << endl;\n}\n\nvoid test1(Person p) {\n    p.play();\n}\n\nvoid test2(Person &p) {\n    p.play();\n}\n\nvoid test3(Person *p) {\n    p->play();\n}\n\nint main() {\n    Infantry infantry;\n    test1(infantry);\n    test2(infantry);\n    test3(&infantry);\n    return 0;\n}\n```\n\n\n"},{"title":"C++ 继承 二","url":"/2019/03/18/yuque/wn6k1b/","content":"<a name=\"50209578\"></a>\n# C++隐藏\n\n> 父子关系，成员同名，才能隐藏\n\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n\n//.h\nclass Person {\npublic:\n    void eat();\n\nprotected:\n    string m_strName;\n    int m_iAge;\nprivate:\n    string test;\n};\n\nclass Worker : public Person {\npublic:\n    void eat();\n    int m_iSalary;\nprotected:\n    string m_strName;\nprivate:\n};\n\n\n//cpp  这叫定义\nvoid Person::eat() {\n    cout<<\"Person::eat()\"<<endl;\n\n}\nvoid Worker::eat() {\n    Person::m_strName=\"kitty\"; //访问父类的隐藏成员\n    cout<<\"Worker::eat()\"<<endl;\n    cout<<Person::m_strName<<endl;\n}\n\nint main() {\n    Person p;\n    p.eat();\n    Worker w;\n    w.Person::eat();//访问父类的隐藏函数\n    w.eat();\n    return 0;\n}\n```\n\n\n"},{"title":"C++ 继承","url":"/2019/03/18/yuque/dsybzb/","content":"<a name=\"81fc844f\"></a>\n# C++继承\n\n<a name=\"ca61434c\"></a>\n## 公有(public)继承\n\n```cpp\nclass Person {\npublic:\n    void eat();//public 权限\nprotected: //protected 权限\n    string m_strName;\n    int m_iAge;\nprivate://private权限\n    string test;\n};\n\nclass Worker : public Person {\npublic:\n    void work();\n    int m_iSalary;\nprotected:\nprivate:\n};\n```\n\n| 父类成员访问属性 | 继承方式 | 子类成员访问属性 |\n| :---: | :---: | :---: |\n| private成员 | public | 无法访问 |\n| protected成员 | public | protected |\n| public成员 | public | public |\n\n\n<a name=\"b1ad912d\"></a>\n## 保护(protected)继承\n\n| 父类成员访问属性 | 继承方式 | 子类成员访问属性 |\n| --- | --- | --- |\n| private成员 | protected | 无法访问 |\n| protected成员 | protected | protected |\n| public成员 | protected | protected |\n\n\n<a name=\"ddecc837\"></a>\n## 私有(private)继承\n\n| 类成员访问属性 | 继承方式 | 子类成员访问属性 |\n| --- | --- | --- |\n| private成员 | private | 无法访问 |\n| protected成员 | private | private |\n| public成员 | private | private |\n\n\n\n"},{"title":"C++ 第二章","url":"/2019/03/18/yuque/xnc8e7/","content":"<a name=\"f0ac7b25\"></a>\n## C++第二章\n\n`const` 限定符\n\n变量 加上const会变成常量，不可更改值，相当于Java中的final\n\n`&`引用\n\n在C++中引用属于复合类型\n\n```cpp\nint var=200; //定义一个变量\nint &a=var; //引用类型a 记录var值\nint &b;//引用必须初始化\nint &c=200；//引用不能文字变量来初始化\n```\n引用别名\n\n```cpp\nint year = 2017; //定义一个变量\nint &a= year; //引用赋值\nint &name =a, &name2 =a; //定义两个引用别名 name ，name2\n\nint time= 10.20;\nint &name= time; // × 错误， 引用赋值后不能再重新引用到别的对象上。\n```\n\n`typedef` 类型别名\n\n```cpp\ntypedef int zhengxing; //别名 zhengxing 为 int类型\nzhengxing  a=1; //类型别名 实际zhengxing 为int 类型\n```\n\n`goto` 无条件跳转\n\n```cpp\nint main(){\n\tint a=1;\n\tcout <<\"a的值为：\"<< a << endl; // 1\n\tgoto theare;\n\tcout << \"a加1的值为：\"<< a+1 << endl;\n\tthear:\n\tcout << \"a加1的值为：\"<< a+2 << endl; //直接跳到这里 输出 3\n\tretuen 0;\n}\n```\n\n`String` 类\n\n```cpp\nString a = \"a\";\nString b = \"b\";\nString c = \"c\"+\"d\";// × 不允许， 加号左右必须有一个类型为String类型才可以\n```\n\n\n"},{"title":"C++ 第一章","url":"/2019/03/18/yuque/nk857b/","content":"<a name=\"6dc5ca63\"></a>\n# C++ 基本知识\n\n* C++编译过程<br />\n* 源文件(_.cpp)->目标文件(_.obj)->可执行文件(*.exe)\n* C++命名规则<br />\n* 只能使用字母字符数字和下划线（_）\n* 第一个不能是数字\n* **C++是区分大小写的**\n* 不能使用C++关键词\n* 命名空间<br />\n* `using namespace` 指明来自哪个空间\n* 头文件\n* 有两种使用方式\n```cpp\n#include<*> //尖括号是标准头文件预先检查\n\n#include\".*\" //用户自己提供的头文件\n```\n\n\n\n* 基本数据类型\n\n| 类型 | 大小 |\n| :--- | :--- |\n| short int | 16 |\n| int | 16 |\n| long int | 32 |\n| char | 8 |\n| wchar_t | 16 |\n| bool | N/A |\n| float | 6 |\n| double | 10 |\n| long double | 10 |\n\n\n\n"},{"title":"C++ 纯虚函数","url":"/2019/03/18/yuque/wbqfdt/","content":"<a name=\"92e6a6f4\"></a>\n# C++纯虚函数（抽象类）\n\n> 纯虚函数类似JAVA中的抽象类\n> 如果父类有纯虚函数，子类继承时，如果不去实现这个函数，则不能被实例化\n\n\n<a name=\"6b8732ce\"></a>\n## 没有实现纯虚函数：\n\n```cpp\n#include <iostream>\n/**\n * C++纯虚函数（抽象类）\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    virtual double calcArea();\n\n    virtual void test()=0;\n};\n\nclass Circle : Shape {\npublic:\n    Circle(int r);\n\n    ~Circle();\n\n\nprotected:\n    int m_r;\n};\n\nCircle::Circle(int r) {\n    m_r = r;\n}\n\nCircle::~Circle() {\n\n}\n\nShape::Shape() {\n\n}\n\nShape::~Shape() {\n\n}\n\ndouble Shape::calcArea() {\n\n}\n\nint main() {\n    //纯虚函数\n    Circle circle(2); //直接报错，无法编译， 没有实现纯虚函数\n\n    return 0;\n}\n```\n\n<a name=\"dc26957d\"></a>\n## 实现纯虚函数\n\n```cpp\n#include <iostream>\n/**\n * C++纯虚函数（抽象类）\n */\n\nusing namespace std;\n\nclass Shape {\npublic:\n    Shape();\n\n    ~Shape();\n\n    virtual double calcArea();\n\n    virtual void test()=0;\n};\n\nclass Circle : Shape {\npublic:\n    Circle(int r);\n\n    ~Circle();\n\n    virtual void test();\n\nprotected:\n    int m_r;\n};\n\nCircle::Circle(int r) {\n    m_r = r;\n}\n\nCircle::~Circle() {\n\n}\n\nvoid Circle::test() {\n    cout << \"test()\" << endl;\n}\n\nShape::Shape() {\n\n}\n\nShape::~Shape() {\n\n}\n\ndouble Shape::calcArea() {\n\n}\n\nint main() {\n    //纯虚函数\n    Circle circle(2); //实现纯虚函数后 编译执行通过\n\n    return 0;\n}\n```\n\n\n"},{"title":"相机参数知识","url":"/2019/03/18/yuque/zr6nul/","content":"> 大疆无人机会机载相机，所以需要学会一些相机的参数，便于快速开发调试无人机\n\n\n<a name=\"499eb315\"></a>\n### 相机模式\n\n1. **AF/自动对焦：**\n1. 自动对焦模式又分为三种（单次/连续/手动）\n1. 单次对焦：只对焦一次\n1. 连续对焦：会多次尝试对焦\n1. 手动：就是手动\n1. **MF/手动对焦**\n<a name=\"3d84a805\"></a>\n### 曝光三大要素\n\n1. **快门：**\n1. 控制拍照时间\n1. **光圈：**\n1. 控制相机接收的光亮\n1. **ISO：**\n1. 白平衡\n\n<a name=\"befa6c49\"></a>\n### 拍照模式\n\n1. **P/程序自动挡：**\n1. 相机自动控制光圈快门，其他的设置需要手动，例如/IOS白平衡\n1. **A/光圈优先挡：**\n1. 相机自动快门，光圈自己设置（光圈值越小，光圈越大，光圈越大，景深越好）\n1. 快门时间越慢捕捉的光线就越多，如果发生抖动的话，照片会糊掉\n1. **Auto：**\n1. 全自动\n1. **M/手动：**\n1. 手动\n\n\n"},{"title":"类对象定义 三","url":"/2019/03/18/yuque/uov3uy/","content":"<a name=\"88a1a4d3\"></a>\n## 浅拷贝\n\n> 浅拷贝：拷贝后，两个对象会共同指向一个地址，如果有一个对象更改了数据，另一个对象也会受影响，删除对象话，可能会导致释放两次\n\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n//.h\nclass student {\npublic:\n    student();\n    student(string name);\n    student(const student &stu);\n    ~student();\n    string getName();\n    int age;\nprivate:\n    string m_name;\n};\n\n//cpp  这叫定义\nstudent::student() {\n    m_name=\"kitty\";\n    m_p=new int[5];\n    cout<<\"gou zao\"<<endl;\n}\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\n//拷贝构造函数 （浅拷贝）\nstudent::student(const student &stu) {\n// 如果通过  student stu1=stu  这样的方式创建度对象，会执行拷贝构造函数\n    m_name=stu.m_name; //浅拷贝\n    m_p=stu.m_p;//浅拷贝 将复制的对象的 指针拷贝给了 另一个对象， 现在两个对象 共同指向了一个 地址\n\n    cout<<\"qian kaobei\"<<endl;\n}\nstudent::~student() {\n    delete []m_p; //这样删除的话，浅拷贝会出问题\n    cout<<\"xi gou\"<<endl;\n}\nvoid student::printAddr() {\n    cout<<\"dizhi:\"<<*m_p<<endl;\n}\nvoid test(student s){\n\n}\nint main() {\n    student s;\n    student s1(s);\n    \n    s.printAddr();\n    s1.printAddr();\n\n    return 0;\n}\n```\n\n<a name=\"510a44e6\"></a>\n## 深拷贝\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n//.h\nclass student {\npublic:\n    student();\n    student(string name);\n    student(const student &stu);\n    ~student();\n    string getName();\n    void printAddr();\nprivate:\n    int count;\n    string m_name;\n    int *m_p;\n};\n\n//cpp  这叫定义\nstudent::student() {\n    m_name=\"kitty\";\n    count=5;\n    m_p=new int[count]; //初始化数组\n    for (int i = 0; i < 5; i++) {//数组赋值\n        m_p[i]=i;\n        cout<<\"value:\"<<m_p[i]<<endl;\n    }\n    cout<<\"gou zao\"<<endl;\n}\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\n//拷贝构造函数 （深拷贝）\nstudent::student(const student &stu) {\n    count=stu.count;\n    //深拷贝 重新开辟一块内存空间\n    m_p=new int [count];\n    for (int i = 0; i <count; i++)\n    {\n        m_p[i]=stu.m_p[i];\n    }\n    cout<<\"shen kaobei\"<<endl;\n}\nstudent::~student() {\n    delete []m_p;\n    cout<<\"xi gou\"<<endl;\n}\nvoid student::printAddr() {\n    cout<<\"dizhi:\"<<m_p<<endl;\n}\n\nvoid test(student s){\n\n}\nint main() {\n    student s;\n    student s1(s);\n    s.printAddr();\n    s1.printAddr();\n    return 0;\n}\n```\n\n<a name=\"4d7294a1\"></a>\n## 对象指针\n\n```c\nint main() {\n    student *s=new student();\n    s->printAddr();\n    student *s1=new student();\n    (*s1).printAddr();\n    return 0;\n}\n```\n\n<a name=\"2278833b\"></a>\n## 对象成员指针\n\n> 对象成员指针 类似JAVA中的 对象属性\n> 例如：private Bean  bean;\n> 指针类型大小为：4\n\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\n\nclass Teacher {\npublic:\n    Teacher(string name, int age);\n\n    ~Teacher();\n\n    string getName();\n\n    int getAge();\n\nprivate:\n    string m_Name;\n    int m_Age;\n};\n\n\n//.h\nclass Student {\npublic:\n    Student(string nameA, int ageA, string nameB , int ageB);\n\n    ~Student();\n\n    void printInfo();\n\nprivate:\n    Teacher *m_teacherA;\n    Teacher *m_teacherB;\n};\n\n\nTeacher::Teacher(string name, int age) {\n    m_Name = name;\n    m_Age = age;\n    cout << \"Teacher gou zao name: \" << m_Name << \" age: \" << m_Age << endl;\n}\n\nTeacher::~Teacher() {\n    cout << \"Teacher xi gou name: \" << m_Name << \" age: \" << m_Age << endl;\n}\n\nint Teacher::getAge() {\n    return m_Age;\n}\n\nstring Teacher::getName() {\n    return m_Name;\n}\n\n\n//cpp  这叫定义\nStudent::Student(string nameA, int ageA, string nameB , int ageB)  {\n\n    m_teacherA=new Teacher(nameA,ageA);\n    m_teacherB=new Teacher(nameB,ageB);\n    cout << \"Student gou zao\" << endl;\n}\n\nStudent::~Student() {\n    delete m_teacherA;\n    delete m_teacherB;\n    cout << \"Student xi gou\" << endl;\n}\nvoid Student::printInfo() {\n    cout << \"printInfo\" << endl;\n\n    cout << \"( A: \" <<m_teacherA->getName()<<\",\"<<m_teacherA->getAge()<<\")\"<< endl;\n\n    cout << \"( B: \" <<m_teacherB->getName()<<\",\"<<m_teacherB->getAge()<<\")\"<< endl;\n}\n\nint main() {\n\n    Student *s=new Student(\"kitty\",20,\"tony\",22);\n    (*s).printInfo();\n    cout<< sizeof(s)<<endl;\n    cout<< sizeof(Student)<<endl;\n    delete s;\n    return 0;\n}\n```\n\n```cpp\n输出结果：\nTeacher gou zao name: kitty age: 20\nTeacher gou zao name: tony age: 22\nStudent gou zao\nprintInfo\n( A: kitty,20)\n( B: tony,22)\n4\n8\nTeacher xi gou name: kitty age: 20\nTeacher xi gou name: tony age: 22\nStudent xi gou\n```\n\n<a name=\"e95a86a0\"></a>\n## this 指针\n\n> 和JAVA中的this指针差不多一个意思\n\n\n\n"},{"title":"类对象定义 二","url":"/2019/03/18/yuque/yuai84/","content":"<a name=\"718a1219\"></a>\n# 类对象定义\n\n<a name=\"3105c212\"></a>\n## C++类访问修饰符\n\n> 数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 `public、private、protected` 来指定的。关键字 `public、private、protected` 称为访问修饰符。\n\n\n```cpp\nclass Base {\n \n   public:\n \n  // 公有成员\n \n   protected:\n \n  // 受保护成员\n \n   private:\n \n  // 私有成员\n \n};\n```\n\n<a name=\"7600eb64\"></a>\n## 公共（public）成员\n\n> **公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：\n\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \nclass Line\n{\n   public:\n      double length;\n      void setLength( double len );\n      double getLength( void );\n};\n \n// 成员函数定义\ndouble Line::getLength(void)\n{\n    return length ;\n}\n \nvoid Line::setLength( double len )\n{\n    length = len;\n}\n \n// 程序的主函数\nint main( )\n{\n   Line line;\n \n   // 设置长度\n   line.setLength(6.0); \n   cout << \"Length of line : \" << line.getLength() <<endl;\n \n   // 不使用成员函数设置长度\n   line.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of line : \" << line.length <<endl;\n   return 0;\n}\n```\n\n<a name=\"ba1438a3\"></a>\n## 私有（private）成员\n\n> **私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。\n> 只有类和友元函数可以访问私有成员。\n> 默认情况下，类的所有成员都是私有的。\n\n\n```cpp\n#include <iostream>\n \nusing namespace std;\n \nclass Box\n{\n    //double width; 不填写权限，默认是私有权限修饰符\n   public:\n      double length;\n      void setWidth( double wid );\n      double getWidth( void );\n \n   private:\n      double width;\n};\n \n// 成员函数定义\ndouble Box::getWidth(void)\n{\n    return width ;\n}\n \nvoid Box::setWidth( double wid )\n{\n    width = wid;\n}\n \n// 程序的主函数\nint main( )\n{\n   Box box;\n \n   // 不使用成员函数设置长度\n   box.length = 10.0; // OK: 因为 length 是公有的\n   cout << \"Length of box : \" << box.length <<endl;\n \n   // 不使用成员函数设置宽度\n   // box.width = 10.0; // Error: 因为 width 是私有的\n   box.setWidth(10.0);  // 使用成员函数设置宽度\n   cout << \"Width of box : \" << box.getWidth() <<endl;\n \n   return 0;\n}\n```\n\n<a name=\"6d8a6091\"></a>\n## 保护（protected）成员\n\n> **保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。\n\n\n```cpp\n#include <iostream>\nusing namespace std;\n \nclass Box\n{\n   protected:\n      double width;\n};\n \nclass SmallBox:Box // SmallBox 是子类（继承关系）\n{\n   public:\n      void setSmallWidth( double wid );\n      double getSmallWidth( void );\n};\n \n// 子类的成员函数\ndouble SmallBox::getSmallWidth(void)\n{\n    return width ;\n}\n \nvoid SmallBox::setSmallWidth( double wid )\n{\n    width = wid;\n}\n \n// 程序的主函数\nint main( )\n{\n   SmallBox box;\n \n   // 使用成员函数设置宽度\n   box.setSmallWidth(5.0);\n   cout << \"Width of box : \"<< box.getSmallWidth() << endl;\n \n   return 0;\n}\n```\n\n<a name=\"4f576e79\"></a>\n## 继承中的特点\n\n> 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。\n> * 1.**public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private\n* 2.**protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private\n* 3.**private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private\n> \n但无论哪种继承方式，上面两点都没有改变：\n> * 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；\n* 2.protected 成员可以被派生类访问。\n\n\n<a name=\"23558bc0\"></a>\n### public 继承\n\n```cpp\n#include<iostream>\n#include<assert.h>\nusing namespace std;\n \nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : public A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中仍是public成员。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中仍是protected可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;\n  cout << b.a1 << endl;   //正确\n  cout << b.a2 << endl;   //错误，类外不能访问protected成员\n  cout << b.a3 << endl;   //错误，类外不能访问private成员\n  system(\"pause\");\n  return 0;\n}\n```\n\n<a name=\"61bf1823\"></a>\n### protected 继承\n\n```cpp\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : protected A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类的public成员，在派生类中变成了protected，可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中还是protected，可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a2 << endl;      //错误，protected成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n<a name=\"86a3ec15\"></a>\n### private 继承\n\n```cpp\n#include<iostream>\n#include<assert.h>\nusing namespace std;\nclass A{\npublic:\n  int a;\n  A(){\n    a1 = 1;\n    a2 = 2;\n    a3 = 3;\n    a = 4;\n  }\n  void fun(){\n    cout << a << endl;    //正确\n    cout << a1 << endl;   //正确\n    cout << a2 << endl;   //正确\n    cout << a3 << endl;   //正确\n  }\npublic:\n  int a1;\nprotected:\n  int a2;\nprivate:\n  int a3;\n};\nclass B : private A{\npublic:\n  int a;\n  B(int i){\n    A();\n    a = i;\n  }\n  void fun(){\n    cout << a << endl;       //正确，public成员。\n    cout << a1 << endl;       //正确，基类public成员,在派生类中变成了private,可以被派生类访问。\n    cout << a2 << endl;       //正确，基类的protected成员，在派生类中变成了private,可以被派生类访问。\n    cout << a3 << endl;       //错误，基类的private成员不能被派生类访问。\n  }\n};\nint main(){\n  B b(10);\n  cout << b.a << endl;       //正确。public成员\n  cout << b.a1 << endl;      //错误，private成员不能在类外访问。\n  cout << b.a2 << endl;      //错误, private成员不能在类外访问。\n  cout << b.a3 << endl;      //错误，private成员不能在类外访问。\n  system(\"pause\");\n  return 0;\n}\n```\n\n\n"},{"title":"类对象定义 一","url":"/2019/03/18/yuque/zqi5k0/","content":"指针类型通过`->`来访问属性\n\n类对象通过`.`来访问属性\n\n<a name=\"9b5c4a26\"></a>\n## 类外定义\n\n<a name=\"464d301a\"></a>\n### .h 定义声明类\n\n```c\n#ifndef CPPDEMO_DUIXIANG_H\n#define CPPDEMO_DUIXIANG_H\n\n#include <string>\nusing namespace std;\n/**\n  类头文件\n*/\nclass demo {\npublic:\n\n    void setAge(int _age);\n    int getAge();\n\n    void setName(string _name);\n    string getName();\n\n\nprivate:\n    string name;\n    int age;\n};\n\n\n#endif //CPPDEMO_DUIXIANG_H\n```\n\n<a name=\"cdf1535e\"></a>\n### cpp实现定义头文件\n\n```c\n#include \"demo.h\"\nvoid demo::setAge(int _age) {\n    age=_age;\n}\nvoid demo::setName(string _name) {\n    name=_name;\n}\nint demo::getAge() {\n    return age;\n}\nstring demo::getName() {\n    return name;\n}\n```\n\n<a name=\"d1c74b98\"></a>\n### 使用对象\n\n```c\n#include <iostream>\n#include <string>\n#include \"demo.h\"\n\nusing namespace std;\n\nint main() {\n   demo m;\n    m.setAge(12);\n    m.setName(\"guolei\");\n\n    cout<<\"年龄:\"<<m.getAge()<<\" 名字: \"<<m.getName()<<endl;\n    return 0;\n}\n```\n\n<a name=\"81b1781e\"></a>\n## 构造函数\n\n```c\n#include <iostream>\n\nusing namespace std;\n\nclass student {\npublic:\n    student();\n    student(string name);\n    string getName();\nprivate:\n    string m_name;\n};\n\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\nstudent::student() {\n    cout << \"无参构造函数\" <<  endl;\n}\n\nint main() {\n    student *s= new student();//无参构造函数\n    \n    student *s2=new student(\"kitty2\");//有参构造函数\n\n    std::cout << \"Hello, World!\" << \"name:\"<< s->getName() <<std::endl;\n    \n    std::cout << \"Hello, World!\" << \"name:\"<< s2->getName() <<std::endl;\n\n    return 0;\n}\n```\n\n<a name=\"a6196df0\"></a>\n## 构造函数初始化列表\n\n> const 类型 只能通过 初始化列表来 初始化数据\n\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nclass student {\npublic:\n/**\n    student::student( string name): m_name(name)\n    {\n        cout << \"初始化列表 \" <<  endl;\n    }\n    上面的语法等同于如下语法：\n    \n    student::student( string name)\n    {\n        m_name = name;\n    }\n    \n\t假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的\t 字段使用逗号进行分隔，如下所示：\n\t\n    C::C( double a, double b, double c): X(a), Y(b), Z(c)\n    {\n        ....\n    }\n    \n */\n    student():m_name(\"kittyg\"),age(20){} //初始化列表 初始化字段\n    \n    student(string name);//带参构造函数\n    \n    string getName();\n    \n    int getAge();\nprivate:\n    string m_name;\n    \n    int age;\n};\n\n\nint main() {\n    student *s= new student();\n    \n    student *s2=new student(\"kitty2\");\n\n    std::cout << \"Hello, World!\" << \"name:\"<< s->getName() <<\" age:\"<<s->getAge()<<std::endl;\n    \n    std::cout << \"Hello, World!\" << \"name:\"<< s2->getName() <<std::endl;\n\n    return 0;\n}\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\nint student::getAge() {\n    return age;\n}\n```\n\n<a name=\"29028255\"></a>\n## 拷贝构造函数\n\n> 定义格式： 类名（const类名&变量名）\n> 如果没有自定义拷贝构造函数则自动生成一个默认的拷贝构造函数\n> 当采用直接初始化或复制初始化实例化对象时，自动调用拷贝构造函数\n\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n//.h\nclass student {\npublic:\n    student():m_name(\"kittyg\"),age(20){}//列表初始化字段\n    student(string name);\n    student(const student &stu);//拷贝构造函数\n    string getName();\n    int getAge();\nprivate:\n    string m_name;\n    int age;\n};\n\n//cpp\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\nint student::getAge() {\n    return age;\n}\n\nstudent::student(const student &stu) { //实现拷贝构造函数\n    cout<<\"keo bei\"<<endl;\n}\n//测试函数\nvoid test(student s){\n\n}\nint main() {\n    student s;\n    student *s2=new student(\"kitty2\");\n    student s3=s;\n    test(s3); //函数传递对象的时候 也会触发 拷贝构造函数\n\n    std::cout << \"Hello, World!\" << \"name:\"<< s.getName() <<\" age:\"<<s.getAge()<<std::endl;\n\n    std::cout << \"Hello, World!\" << \"name:\"<< s2->getName() <<std::endl;\n\n    return 0;\n}\n```\n\n<a name=\"a01f6c31\"></a>\n## 析构函数\n\n> 主要用于善后处理，一般用于释放内存\n> 如果没有自定义析构函数则自动生成\n> 析构函数在对象销毁时自动调用\n> 析构函数没有返回值，没有参数也不能重载\n\n\n`对象的生命历程`\n\n申请内存->初始化列表->构造函数->参与运算或执行逻辑->析构函数->释放内存\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n//.h\nclass student {\npublic:\n    student();\n    student(string name);\n    student(const student &stu);//拷贝构造函数\n    ~student();//析构构造函数\n    string getName();\nprivate:\n    string m_name;\n};\n\n//cpp\nstudent::student() {}\nstring student::getName(){\n    return m_name;\n}\nstudent::student(string name) {\n    m_name=name;\n}\nstudent::student(const student &stu) {\n    cout<<\"keo bei\"<<endl;\n}\nstudent::~student() {\n    cout<<\"xi gou\"<<endl;\n}\n\nvoid test(student s){\n\n}\nint main() {\n    student s;\n    student *s2=new student(\"kitty2\");\n    \n    std::cout << \"Hello, World!\" << \"name:\"<< s2->getName() <<std::endl;\n\n    delete  s2;// 触发析构函数\n\n    return 0;\n}\n```\n\n\n"},{"title":"WEB前端 HTML标签","url":"/2019/03/18/yuque/xqfp88/","content":"<a name=\"48077199\"></a>\n## HTML标签\n\n```html\n标题标签:<h1>、<h2>、<h3> 注：  h1 标签因为重要，尽量少用, 一般h1 都是给logo使用。\n\n段落标签: <p>\n\n水平线标签: <hr /> 注:是单标签\n\n换行标签: <br />\n\n盒子标签： div span div ：分区 span：度，跨距\n\n文本格式化标签： \n<b></b><strong></strong> 文本加粗 \n<i></i><em></em> 文本倾斜\n<s></s><del></del> 文本删除线\n<u></u><ins></ins> 文本下划线\n```\n\n<a name=\"3593d468\"></a>\n## 标签属性\n\n```html\n<标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …> 内容 </标签名>\n```\n\n<a name=\"f680fd7b\"></a>\n### 标签属性场景\n\n```html\n<!---水平线--->\n<hr width=\"400\" />\n<!---图像--->\n<img src=\"图像URL\" />\n<!---链接--->\n<a href=\"跳转目标\" target=\"目标窗口的弹出方式\">文本或图像</a>\n```\n\n<a name=\"28bddf00\"></a>\n## 列表标签\n\n```html\n<!---\n 1. <ul></ul>中只能嵌套<li></li>，直接在<ul></ul>标签中输入其他标签或者文字的做法是不被允许的。\n 2. <li>与</li>之间相当于一个容器，可以容纳所有元素。\n---->\n\n<!---无序列表--->\n<ul>\n  <li>列表项1</li>\n  <li>列表项2</li>\n  <li>列表项3</li>\n  ......\n</ul>\n\n<!---有序列表--->\n<ol>\n  <li>列表项1</li>\n  <li>列表项2</li>\n  <li>列表项3</li>\n  ......\n</ol>\n\n<!---自定义列表--->\n<dl>\n  <dt>名词1</dt>\n  <dd>名词1解释1</dd>\n  <dd>名词1解释2</dd>\n  ...\n</dl>\n```\n\n<a name=\"9c942d88\"></a>\n# 表格标签\n\n```html\n<table width=\"500\" height=\"300\" border=\"1\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">\n  <caption>表格标题</caption>\n    <thead>\n    \t<tr>\n    \t\t<th>姓名</th>\n    \t\t<th>性别</th>\n    \t\t<th>年龄</th>\n    \t</tr>\n    </thead>\n\t<tbody>\n    \t<tr>\n    \t\t<td>小明</td>\n    \t\t<td>男</td>\n    \t\t<td rowspan=\"3\">18</td>\n    \t</tr>\n    \t<tr>\n    \t\t<td>李磊</td>\n    \t\t<td>男</td>\n    \t</tr>\n    \t<tr>\n    \t\t<td>kitty</td>\n    \t\t<td>男</td>    \t\t\n    \t</tr>\n    \t<tr>\n    \t\t<td colspan=\"3\">胖虎</td> \t\t\n    \t</tr>\n    </tbody>\n</table>\n```\n\n<a name=\"ea912bc3\"></a>\n## 表单标签\n\n```html\n<form action=\"xxx.php\" method=\"get\" name=\"userMessage\">\n\t\t用户名: <input type=\"text\" value=\"提示\"/>   <!-- 这是一个文本框 --> <br/>\n\t\t密　码: <input type=\"password\" maxlength=\"6\"/> <br/>  \n\t\t性　别:　\n\t\t<input type=\"radio\" name=\"sex\"/> 女\n\t\t<input type=\"radio\" name=\"sex\" checked=\"checked\"/> 男\n\t\t<br/>\n\t\t<!-- 单选框  如果是一组，我们通过相同的name值 来实现-->\n\t\t爱　好:　\n\t\t<input type=\"checkbox\" name=\"hobby\" checked=\"checked\"/> 足球\n\t\t<input type=\"checkbox\" name=\"hobby\"/> 篮球\n\t\t<!-- 复选框 可以同时选择多个 --><br/>\n\t\t按钮： <input type=\"button\" value=\"按钮\"/>  <!-- 普通按钮 --><br/>\n\t\t<input type=\"submit\" value=\"提交表单\"/><!-- 提交按钮 -->\n\t\t<input type=\"reset\" value=\"重置表单\"/><!-- 重置按钮 --><br/>\n\t\t<input type=\"image\" src=\"im.jpg\"/><!-- 图像按钮 --><br/>\n\t\t上传头像:\n\t\t<input type=\"file\"/>  <!-- 文件按钮 -->\n</form>\n```\n\n\n"},{"title":"WEB前端初识","url":"/2019/03/18/yuque/vvkxes/","content":"<a name=\"912302cb\"></a>\n## 浏览器\n\n```\n浏览器是网页运行的平台，常用的五大浏览器：IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera\n```\n\n<a name=\"036c6cd4\"></a>\n## 什么是浏览器内核\n\n```\n内核分为两部分：渲染引擎 和 JS 引擎。  \n\n渲染引擎（layout engineer 或者 Rendering Engine）：负责渲染网页，通过HTML、XML，CSS等，计算网页显示的方式，然后输出至显示器或打印机。（浏览器内核的不同，对应网页的语法解释会有不同，渲染效果也会不同）\n\nJS引擎： 则是解析Javascript 语言，执行 javascript语言来实现网页的动态效果。\n\n注：最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎，但是常见的浏览器内核可以分这四种：Trident（IE）、Gecko（firefox）、Blink（chrome）、Webkit（Safari）。\n\n移动端浏览器内核：\n\tiPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。\n```\n\n<a name=\"c8bb3149\"></a>\n## WEB标准的好处\n\n```\n让Web的发展前景更广阔 \n\n内容能被更广泛的设备访问\n\n更容易被搜寻引擎搜索\n\n降低网站流量费用\n\n使网站更易于维护\n\n提高页面浏览速度\n```\n\n<a name=\"5c22a5a2\"></a>\n## Web 标准构成\n\n主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。\n\n```\n结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。\n样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。\n行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分\n```\n\n<a name=\"ec5d380d\"></a>\n## HTML初识\n\n```\nHTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。\n```\n\n```html\n<!--最简单的HTML网页-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>标题</title>\n</head>\n<body>\n<p>这里是文字</p>\n</body>\n</html>\n```\n\n<a name=\"fc130394\"></a>\n## HTML标签分类\n\n1.双标签\n\n```html\n<标签名> 内容 </标签名>\n```\n\n2.单标签\n\n```html\n<标签名 />\n```\n\n单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。\n\n<a name=\"39148b9a\"></a>\n## 文档类型<!DOCTYPE>\n\n```html\n<!DOCTYPE html>\n```\n<a name=\"4cfb99ed\"></a>\n## 字符集\n\n```html\n<meta charset=\"UTF-8\">\n```\n\nutf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。\n\ngb2312 简单中文  包括6763个汉字\n\nBIG5   繁体中文 港澳台等用\n\nGBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312\n\nUTF-8则包含全世界所有国家需要用到的字符\n\n<a name=\"912302cb-1\"></a>\n## 浏览器\n\n```\n浏览器是网页运行的平台，常用的五大浏览器：IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera\n```\n\n<a name=\"036c6cd4-1\"></a>\n## 什么是浏览器内核\n\n```\n内核分为两部分：渲染引擎 和 JS 引擎。\n渲染引擎（layout engineer 或者 Rendering Engine）：负责渲染网页，通过HTML、XML，CSS等，计算网页显示的方式，然后输出至显示器或打印机。（浏览器内核的不同，对应网页的语法解释会有不同，渲染效果也会不同）\n\nJS引擎 : 则是解析Javascript 语言，执行 javascript语言来实现网页的动态效果。\n\n注：最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎，但是常见的浏览器内核可以分这四种：Trident（IE）、Gecko（firefox）、Blink（chrome）、Webkit（Safari）。\n\n移动端浏览器内核：\n\tiPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。\n```\n\n<a name=\"c8bb3149-1\"></a>\n## WEB标准的好处\n\n```\n让Web的发展前景更广阔 \n\n内容能被更广泛的设备访问\n\n更容易被搜寻引擎搜索\n\n降低网站流量费用\n\n使网站更易于维护\n\n提高页面浏览速度\n```\n\n<a name=\"5c22a5a2-1\"></a>\n## Web 标准构成\n\n主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。\n\n```\n结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。\n样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。\n行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分\n```\n\n<a name=\"ec5d380d-1\"></a>\n## HTML初识\n\n```\nHTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。\n```\n\n```html\n<!--最简单的HTML网页-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>标题</title>\n</head>\n<body>\n<p>这里是文字</p>\n</body>\n</html>\n```\n\n<a name=\"fc130394-1\"></a>\n## HTML标签分类\n\n1.双标签\n\n```html\n<标签名> 内容 </标签名>\n```\n\n2.单标签\n\n```html\n<标签名 />\n```\n\n单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。\n\n<a name=\"39148b9a-1\"></a>\n## 文档类型<!DOCTYPE>\n\n```html\n<!DOCTYPE html>\n```\n<a name=\"4cfb99ed-1\"></a>\n## 字符集\n\n```html\n<meta charset=\"UTF-8\">\n```\n\nutf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。\n\ngb2312 简单中文  包括6763个汉字\n\nBIG5   繁体中文 港澳台等用\n\nGBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312\n\nUTF-8则包含全世界所有国家需要用到的字符\n\n\n"},{"title":"Web","url":"/2019/03/04/yuque/erfi70/","content":"![b.jpg](https://cdn.nlark.com/yuque/0/2019/jpeg/259158/1551632785846-0601c7b7-3063-40ad-bcff-b0b4fe7b80ef.jpeg#align=left&display=inline&height=121&name=b.jpg&originHeight=300&originWidth=400&size=19101&status=done&width=161)<br />这是一个测试页面,来着语雀！\n\n"},{"title":"About","url":"/2016/04/21/about/index/","content":"# 关于博客\n\n> 昵称：kitty  \n\n> 职业：Android开发工程师   \n\n> 经验：物联网(无人机、NB-IOT、智能硬件)、前端(JS、CSS、HTML)、C++(略懂一些)  \n\n> 内容：都是一些琐碎的文章，对感兴趣的新技术会写些文章用来记录.   \n\n## 博客经历\n> 最早是在CSDN写文章，后来发现体验糟糕的狠，决定自己搭建博客，之前是在阿里云搭建，图片存在七牛云(由于用的是测试域名和空间，被七牛云清空了，导致部分文章没有配图)，服务器到期后换用Coding，Coding三天两头抽风，外加频繁更新导致Pages不稳定，为了不再折腾，转移到了GitHub,文章现在托管在阿里[语雀平台][1]上。\n\n\n  [1]: https://www.yuque.com/kitty-obmha"}]